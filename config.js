export const bio = '于我常在'
export const cardData = [
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/16',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/16/labels{/name}',
    comments_url:
      'https://api.github.com/repos/Aisen60/blog/issues/16/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/16/events',
    html_url: 'https://github.com/Aisen60/blog/issues/16',
    id: 661593159,
    node_id: 'MDU6SXNzdWU2NjE1OTMxNTk=',
    number: 16,
    title: 'vue 中的"观察者模式" 和 "发布订阅模式"',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1929143897,
        node_id: 'MDU6TGFiZWwxOTI5MTQzODk3',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/Vue',
        name: 'Vue',
        color: '42b983',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-07-20T09:29:26Z',
    updated_at: '2020-07-20T09:29:34Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '# 观察者模式是什么？\r\n观察者模式是对象中的一种一对多的依赖关系，当对应的状态发生改变时，执行相应的更新。\r\n\r\n观察者模式有两个概念，分别是：\r\n- 目标（发布者），```发布者```它会记录所有的```订阅者```，当状态发生改变时，由```发布者```通知```订阅者```\r\n- 观察者（订阅者） 所有的订阅者都有一个```update```方法，这个方法是用于处理状态发生改变时的业务。\r\n\r\n**Vue响应机制中使用了观察者模式，在vue响应机制中，当数据变化的时候会调用观察者的update方法，update方法内部就是更新视图**\r\n\r\n在观察者模式中，订阅者的update方法是由发布者调用的。\r\n\r\n# 实现一个简单的观察者模式\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang="en">\r\n\r\n<head>\r\n    <meta charset="UTF-8">\r\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\r\n    <title>观察者模式</title>\r\n</head>\r\n\r\n<body>\r\n    <script>\r\n        // 目标-发布者\r\n        class Dep {\r\n            constructor() {\r\n                this.subs = [];\r\n            }\r\n            // 添加观察者\r\n            addSub(sub) {\r\n                if (sub && sub.update) {\r\n                    this.subs.push(sub)\r\n                }\r\n            }\r\n            // 通知观察者\r\n            notify() {\r\n                this.subs.forEach(sub => {\r\n                    sub.update()\r\n                })\r\n            }\r\n        }\r\n\r\n        // 观察者-订阅\r\n        class Watcher {\r\n            update() {\r\n                console.log("update")\r\n            }\r\n        }\r\n\r\n        let dep = new Dep()\r\n        let watcher = new Watcher()\r\n        dep.addSub(watcher)\r\n        dep.notify()\r\n\r\n    </script>\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n# 发布订阅模式是什么？\r\n发布订阅模式是对象中的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖与它的对象都将得到状态改变的通知。\r\n\r\n发布定于模式有三个概念，分别是：\r\n- 订阅者，订阅者的作用是：向调度中心注册一个事件，这个事件的作用是处理状态改变后的业务。\r\n- 发布者，发布者的作用是：向调度中心发起一个状态改变的通知。\r\n- 调度中心，调度中心的作用是：将发布者状态改变时向调度中心发送的通知，告知给订阅者。\r\n\r\n看似很陌生，其实在工作中经常会用到。例如:\r\n\r\n- node.js 中 EventEmitter 中的 ```on``` 和 ```emit```\r\n- vue.js 中的 ```$on``` 和 ```$emit```\r\n\r\n**他们都使用了发布订阅模式**\r\n\r\n# 例子\r\n我们就拿微信公众号来举例子，我们很喜欢一个公众号的文章，但是我们不知道这个公众号什么时候发布文章，要不定时的去翻一翻。这个时候我们可以订阅这个公众号，每当这个公众号发布了新的文章的时候，我们就会收到通知。\r\n\r\n**这个例子中的发布者就是当前这个```公众号```，我们就是```订阅者```，微信就是```调度中心```**\r\n\r\n# 实现一个简单的发布订阅模式\r\n```html\r\n<!DOCTYPE html>\r\n<html lang="en">\r\n\r\n<head>\r\n    <meta charset="UTF-8">\r\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\r\n    <title>发布订阅模式</title>\r\n</head>\r\n\r\n<body>\r\n\r\n</body>\r\n\r\n</html>\r\n\r\n<script>\r\n    class EventEmitter {\r\n        constructor() {\r\n            //设置对象的原型\r\n            // { \'click\': [fn1, fn2], \'change\': [fn] }\r\n            this.subs = Object.create(null)\r\n        }\r\n        // 注册事件\r\n        $on(eventType, handler) {\r\n            this.subs[eventType] = this.subs[eventType] || []\r\n            this.subs[eventType].push(handler)\r\n        }\r\n        // 触发事件\r\n        $emit(eventType) {\r\n            if (this.subs[eventType]) {\r\n                this.subs[eventType].forEach(handler => {\r\n                    handler();\r\n                })\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<script>\r\n    // 调度中心\r\n    let dispatch = new EventEmitter()\r\n\r\n\r\n    // 注册事件(订阅消息) ，当调度中心有新的信息过来的时候，会触发相对应的函数\r\n    dispatch.$on(\'dataChange\', () => {\r\n        console.log(\'dataChange\')\r\n    })\r\n\r\n    dispatch.$on(\'dataChange\', () => {\r\n        console.log(\'dataChange1\')\r\n    })\r\n    // 触发事件(发布消息)，向调度中心发布信息\r\n    dispatch.$emit(\'dataChange\')\r\n</script>\r\n```\r\n\r\n# 发布者模式和观察者模式的区别\r\n\r\n## 相同点：\r\n都是对象中的一种一对多的依赖关系，当对应的状态发生改变时，执行相应的更新。\r\n\r\n## 不同点：\r\n1、发布者模式有调度中心，观察者模式没有调度中心。\r\n2、发布者模式的更新是由调度中心发起的，而观察者模式的更新是由目标（订阅者）发起的\r\n3、发布者模式，双方并不知道对方的存在，而观察者模式是必须要知道的，基础自定义事件。\r\n4、发布者模式是低耦合的，而观察者是高耦合的。\r\n\r\n使用场景：\r\n观察者模式：vue依赖追踪、原生事件\r\n发布订阅模式：vue的组件之间的通信EeventBus，react合成事件\r\n\r\n下面的文章讲的很清楚，可以具体看看：\r\n\r\nhttps://www.jianshu.com/p/594f018b68e7\r\n\r\nhttps://www.cnblogs.com/liuhp/p/12221144.html\r\n',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/15',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/15/labels{/name}',
    comments_url:
      'https://api.github.com/repos/Aisen60/blog/issues/15/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/15/events',
    html_url: 'https://github.com/Aisen60/blog/issues/15',
    id: 655348654,
    node_id: 'MDU6SXNzdWU2NTUzNDg2NTQ=',
    number: 15,
    title: '使用 webpack 实现一个简易版的 vue 项目打包',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1929150686,
        node_id: 'MDU6TGFiZWwxOTI5MTUwNjg2',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/Webpack',
        name: 'Webpack',
        color: '5ba7e4',
        default: false,
        description: '',
      },
      {
        id: 1721385519,
        node_id: 'MDU6TGFiZWwxNzIxMzg1NTE5',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/good',
        name: 'good',
        color: 'ae8a53',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-07-12T07:28:40Z',
    updated_at: '2020-07-13T01:34:24Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '# 使用 webpack 实现一个简易版的 vue 项目打包\r\n\r\n## 目标\r\n\r\n使用 webpack 实现一个使用 Vue CLI 创建出来的 Vue 项目的打包，有所不同的是，我删除了一些关于 webpack 的配置，还有路由等。模板已经放到[github](https://github.com/Aisen60/webpack-vue-template)上了。\r\n\r\n目标是要实现，开发服务器（实现热加载）、ESlint 检查、打包编译。\r\n\r\n思路是，先安装、编写所需要用到的 loader，以及相关的插件，然后安装 webpack-dev-serve 并且 配合 webpack.HotModuleReplacementPlugin 来实现热更新，最后处理 copy 文件，完成最后的打包编译。\r\n\r\n## webpack 是什么\r\n\r\nwebpack 是一个前端的打包工具，它的思想主要是模块化，它把所有的静态文件都视为模块，最终会按照配置文件中的规则，生成优化过后的代码。\r\n\r\n## 准备工作\r\n\r\n去 github 上把这个项目模板下载到本地[webpack-vue-template](https://github.com/Aisen60/webpack-vue-template)。\r\n\r\n下载完后，我们先在控制台安装 webpack、webpack-cli 这两个包，进入项目命令行终端，输入 `yarn add webpack webpack-cli --dev` ，安装完成后，我们打开 webpack.common.js ，来编写一些基础的配置。\r\n\r\n我们先指定 webpack 的打包入口文件，以及打包完成后输出的文件名，代码如下：\r\n\r\n```diff\r\n+ module.exports = {\r\n+   entry: "./src/main.js",\r\n+   output: {\r\n+     filename: "js/bundle.js",\r\n+   },\r\n+   module: {}\r\n+   plugins: []\r\n+ }\r\n```\r\n\r\n在接着，我们打开目录观察一下项目，有下面这几个文件目录：\r\n\r\n- public 静态资源文件夹\r\n- src 源文件目录\r\n- package.json package file\r\n- README.md\r\n- webpack.common.js webpack 配置 通用文件\r\n- webpack.dev.js 开发环境配置\r\n- webpack.prod.js 生产环境配置\r\n\r\n## loader\r\n\r\nloader 机制，是 webpack 的核心，webpack 它不知道如何处理 js 文件以外的文件，所有我们借助 loader 来帮助我们实现除了 js 文件以外的文件的转换编译等。\r\n\r\n我们观察一下 src 目录，src 目录下一共有这几种类型的文件：png、less、vue、js。明白了该处理什么文件类型后，我们就可以开始编写 相关的 loader 了。\r\n\r\n### file-loader 处理 .png 文件\r\n\r\n我们首先来处理一下 png 文件，我们需要 file-loader 来帮我们进行编译。[file-loader 官方文档：https://webpack.js.org/loaders/file-loader/](https://webpack.js.org/loaders/file-loader/)。\r\n\r\n在控制台输入 `yarn add file-loader --dev` 来安装 file-loader 这个 loader，安装完成后，我们打开 webpack.common.js 来编写以下 file-loader 这个任务，其实，你通过官方文档的介绍，可能已经明白了 file-loader 的使用了。我们在 module 中写入配置，代码如下：\r\n\r\nwebpack.common.js:\r\n\r\n```diff\r\nmodule: {\r\n+    rules:[\r\n+        {\r\n+            test: /\\.(png|jpg|gif)$/, // 处理文件后缀名以png、jpg、gif结尾的文件\r\n+            use: [\r\n+                {\r\n+                loader: "file-loader", // 使用 file-loader 这个 loader\r\n+                options: { // 选项配置\r\n+                    name: "[hash].[ext]", // 处理过后的文件名\r\n+                    esModule: false, // 是否开启模块化\r\n+                },\r\n+                },\r\n+            ],\r\n+        },\r\n+    ]\r\n}\r\n```\r\n\r\n当然我们还可以使用 url-loader 来处处理，url-loader 用法请查看官网，这里不做讲解。[url-loader 文档](https://webpack.js.org/loaders/url-loader/)\r\n\r\n**这里需要注意的一个点是，在最新版本中的 file-loader 已经默认启动了模块化，我们需要把 esModule 设置成 false， 不然呢，打包过后的结果就会变成下面这个样子。**\r\n\r\n```html\r\n<img alt="Vue logo" src="[object Module]" />\r\n```\r\n\r\n### less-loader 处理 .less 文件\r\n\r\n接下来，我们处理一下以 less 文件。同样，官网有提供相应的 loader 。[less-loader 官方文档：https://webpack.js.org/loaders/less-loader/](https://webpack.js.org/loaders/less-loader/)。但是光只有 less-loader 是不够的，因为 less-loader 只会帮助我们把 less 转换成 css ，并不会帮我们挂载在页面中 head 中。所以我们还需要 css-loader style-loader 这两个 loader 来帮助我们实现。\r\n\r\n我们在控制台输入 `yarn add less-loader less css-loader style-loader --dev`来安装这几个 loader\r\n\r\n安装完成后，我们在 module 中编写规则，代码如下：\r\n\r\nwebpack.common.js:\r\n\r\n```diff\r\nmodule: {\r\n    rules:[\r\n+       {\r\n+           test: /\\.less$/,\r\n+           use: [\r\n+               {\r\n+                   loader: "style-loader",\r\n+               },\r\n+               {\r\n+                   loader: "css-loader",\r\n+               },\r\n+               {\r\n+                   loader: "less-loader",\r\n+               },\r\n+           ],\r\n+       },\r\n    ]\r\n}\r\n```\r\n\r\n这里需要注意的是，**loader 是从下往上，从右往左执行的**。我们需要先执行 less-loader ，要把 less 转换成 css 给 css-loader 去处理，然后 css-loader 处理完后，交给 style-loader 处理，style-loader 会把处理后的结果，帮我们挂载到页面的 head 中。\r\n\r\n### vue-lodaer 处理 .vue 文件\r\n\r\n接下来，我们来处理 .vue 类型的文件。我们需要用到一个 vue-loader 它是 vue/cli 官方提供的一个 loader ，专门处理以一种名为[单文件组件 (SFCs)](https://vue-loader.vuejs.org/zh/spec.html)的格式撰写的 Vue 组件。[Vue Loader 官方文档](https://vue-loader.vuejs.org/zh/)\r\n\r\n首先，我们需要安装 vue-loader ，同时还要安装一个插件 vue-template-compiler 。在命令行终端输入：`yarn add vue-loadervue-template-compiler --dev`。\r\n\r\n安装完成后，我们来编写相应的规则，代码如下：\r\n\r\nwebpack.common.js:\r\n\r\n```diff\r\n+ const VueLoaderPlugin = require("vue-loader/lib/plugin");\r\nmodule: {\r\n    rules:[\r\n+       {\r\n+           test: /\\.vue$/,\r\n+           loader: "vue-loader",\r\n+       },\r\n   ]\r\n},\r\nplugins: [\r\n+   new VueLoaderPlugin(),\r\n],\r\n```\r\n\r\n编写完 loader 后，根据官方文档的提示，我们还需要在 配置文件中引入 vue-loader/lib/plugin ，并且在把这个插件添加到 plugins 中，代码如下：\r\n\r\n```diff\r\n+ const VueLoaderPlugin = require("vue-loader/lib/plugin");\r\nplugins: [\r\n+   new VueLoaderPlugin(),\r\n],\r\n```\r\n\r\n**官方文档声明，必须要引入这个插件，否则无法正常处理 .vue 文件。**\r\n\r\n根据官方文档的事例中，我们发现，还需要对 .vue 模板中的 css 做处理，需要使用到一个 loader 叫做 vue-style-loader。我们来安装这个 loader。在命令终端输入 `yarn add vue-style-loader --dev` 来安装。\r\n\r\n安装完成后，我们来编写相关的规则，代码如下：\r\n\r\n```diff\r\nmodule: {\r\n    rules:[\r\n+     // 它会应用到普通的 `.css` 文件\r\n+     // 以及 `.vue` 文件中的 `<style>` 块\r\n+     {\r\n+       test: /\\.css$/,\r\n+       use: ["vue-style-loader", "css-loader"],\r\n+     },\r\n      {\r\n        test: /\\.less$/,\r\n        use: [\r\n          {\r\n            loader: "style-loader",\r\n          },\r\n          {\r\n            loader: "css-loader",\r\n          },\r\n          {\r\n            loader: "less-loader",\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n}\r\n```\r\n\r\n### babel-loader 处理 js 文件\r\n\r\n接下来，我们需要处理 .vue 文件 和 js 文件中 js 的代码，我们可以使用 babel-loader 这个 loader 来帮助我们处理 ，官方文档：https://webpack.docschina.org/loaders/babel-loader/ 官方文档中提到，还需要安装 @babel/core @babel/preset-env 这两个包。我们根据官网文档的要求，在命令行终端输入 `yarn add babel-loader @babel/core @babel/preset-env --dev`。\r\n\r\n安装完成后，开始编写 loader 规则 ，代码如下：\r\n\r\nwebpack.common.js:\r\n\r\n```diff\r\nmodule: {\r\n    rules:[\r\n+       // 它会应用到普通的 `.js` 文件\r\n+       // 以及 `.vue` 文件中的 `<script>` 块\r\n+       {\r\n+           test: /\\.js$/,\r\n+           loader: "babel-loader",\r\n+       },\r\n    ]\r\n}\r\n```\r\n\r\n### eslint-loader 检查代码规范\r\n\r\n接下来，我们需要安装 eslint-loader 来帮我们进行代码的检查，官方文档：https://webpack.js.org/loaders/eslint-loader/ 。 我们根据官方文档，我们需要安装 eslint 和 eslint-loader 。在命令行输入 `yarn add eslint eslint-loader --dev` 来安装。\r\n\r\n完成安装后，我们写入规则，代码如下：\r\n\r\nwebpack.common.js:\r\n\r\n```diff\r\nmodule: {\r\n    rules:[\r\n     // 它会应用到普通的 `.js` 文件\r\n     // 以及 `.vue` 文件中的 `<script>` 块\r\n     {\r\n       test: /\\.js$/,\r\n       loader: "babel-loader",\r\n     },\r\n+     {\r\n+       test: /\\.(vue|js)$/, // 需要检查代码的文件类型\r\n+       exclude: /node_modules/, // 不需要检查的目录文件\r\n+       loader: "eslint-loader", // 使用 eslint-loader\r\n+       enforce: "pre",\r\n+       include: [__dirname + "/src"], // 要检查的目录\r\n+     },\r\n    ]\r\n}\r\n```\r\n\r\n至此，我们所有的 loader 已经写完了。\r\n\r\n配置 eslint 有两种方法\r\n\r\n- 通过 `yarn eslint --init`来初始化一个配置文件\r\n- 在 package.json 中的 eslintConfig 编写规则\r\n\r\n模板中已经提供了一个简答的校验规则了，所以我们这里只需要安装相关 loader 就行了。\r\n\r\n或许你可能有疑问，要如何校验这些 loader 是否写的真确？我们可以在启动开发服务器时，去校验这些 loader 和 plugins 是否正确。\r\n\r\n## plugins\r\n\r\n下面，我们来安装几个 plugins 让我们打包更加便捷。\r\n\r\n### HtmlWebpackPlugin\r\n\r\n我们首先打开 public 下的 index.html 文件，可以看到 title 和 strong 标签中使用了一个叫做 htmlWebpackPlugin.options.title 的内容。这个是 HtmlWebpackPlugin 插件的作用之一。\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/87243714-d2c62580-c46a-11ea-8b2e-c49f3e3d463b.png)\r\n\r\nHtmlWebpackPlugin 插件的作用是，在打包完成之后，自动生成一个 html 文件到输出目录中，并且还会自动引入打包编译之后的 js 主文件，可以看到这个插件的 github[官网](https://github.com/jantimon/html-webpack-plugin#configuration)上有文档说明，我们也可以指定一个模板生成 html 文件。在 HtmlWebpackPlugin 配置中，我们还可以设置一些参数，供 index.html 使用，webpack 会一同把它编译。\r\n\r\n我们在命令行终端输入 `yarn add html-webpack-plugin --dev`来安装这个插件。\r\n\r\n安装完成后，在 webpack.common.js 文件中，先引入这个插件，并且在把这个插件添加到 plugins 中，代码如下：\r\n\r\nwebpack.common.js:\r\n\r\n```diff\r\n+ const HtmlWebpackPlugin = require("html-webpack-plugin");\r\nplugins: [\r\n    new VueLoaderPlugin(),\r\n+   new HtmlWebpackPlugin({\r\n+       title: "webpack-vue-template", // 网站 title\r\n+       template: "./public/index.html", // 使用指定的模板\r\n+   }),\r\n]\r\n```\r\n\r\n### webpack.DefinePlugin\r\n\r\n我们打开到 public 下的 index.html 文件，我们看到 link 标签中，有一个 <%= BASE_URL %> 这是个什么东东？\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/87243885-3ac93b80-c46c-11ea-996b-d1bd1fd0b1db.png)\r\n\r\n其实这是一个全局变量，这是 webpack.DefinePlugin 提供的功能，它可以用来定义全局变量，在 webpack 打包的时候会对这些变量做替换。\r\n\r\n它不需要引入而外的插件，只需要引入 webpack 就可以了，代码如下：\r\n\r\nwebpack.common.js:\r\n\r\n```diff\r\n+ const webpack = require("webpack");\r\nconst VueLoaderPlugin = require("vue-loader/lib/plugin");\r\nconst HtmlWebpackPlugin = require("html-webpack-plugin");\r\n```\r\n\r\n再接着，写入 plugins , 代码如下：\r\n\r\n```diff\r\nplugins: [\r\n    new VueLoaderPlugin(),\r\n    new HtmlWebpackPlugin({\r\n        title: "webpack-vue-template",\r\n        template: "./public/index.html",\r\n    }),\r\n+   new webpack.DefinePlugin({\r\n+       BASE_URL: JSON.stringify("./"),\r\n+   }),\r\n],\r\n```\r\n\r\n至此，我们第一步的工作就完成了，我们已经编写完 loader 和 plugins 了。\r\n\r\n## webpack-dev-server\r\n\r\n接下来，我们需要安装 webpack-dev-serve 并且 配合 webpack.HotModuleReplacementPlugin 来启动一个开发服务器并且实现热更新。\r\n\r\n我们在命令行终端输入：`yarn add webpack-dev-server --dev` ，安装完成后，我们还需要安装 webpack-merge，它的作用主要是帮助我们合拼覆盖原有的配置。在终端输入 `yarn add webpack-merge --dev`完成安装。\r\n\r\n其实我们之前的所有的工作，都是在 webpack.common.js 中编写的，我们把通用的部分，抽离出了一个文件，接着，我们可以通过 merge 在指定的环境帮我们合拼覆盖原有的配置。\r\n\r\n我们打开 webpack.dev.js 文件，开始编写启动服务器这个任务，代码如下：\r\n\r\nwebpack.dev.js\r\n\r\n```javaScript\r\n// 引入这个插件，在最新版本中，它不在返回一个函数，而是返回一个对象，我们需要进行结构操作。\r\nconst { merge } = require("webpack-merge");\r\n// 引入我们抽离出来的公共模块\r\nconst common = require("./webpack.common");\r\n// 合拼 common ，并且编写新的内容，覆盖原基础文件\r\nmodule.exports = merge(common, {\r\n  mode: "development", // 设置为 development 觅食\r\n  devtool: "cheap-eval-module-source-map", // 开启source-map\r\n  devServer: { // 启动服务器\r\n    host: "localhost", // 主机地址\r\n    port: "6060", // 端口\r\n    open: true, // 是否自动打开浏览器\r\n    contentBase: "public", // 告诉服务器从public目录提供静态文件\r\n  },\r\n});\r\n```\r\n\r\n好了，编写完后，我们在命令行终端，输入 `yarn webpack-dev-server --open --config webpack.dev.js` 来启动我们的服务器。**在这个启动服务器的时，我们可以校验，我们之前写的 loader 和 plugins 是否有问题。**启动的过程需要稍等一会，因为 eslint 会去校验代码，如果我们的代码写的不规范，控制台会给出提示。\r\n\r\n如果一切顺利，系统会打开默认浏览器并且帮我打开http://localhost:6060/，效果如下：\r\n\r\n<img  alt="https://user-images.githubusercontent.com/19791710/87244963-f3df4400-c473-11ea-975c-0dfcd400962a.png" src="https://user-images.githubusercontent.com/19791710/87244963-f3df4400-c473-11ea-975c-0dfcd400962a.png">\r\n\r\n接下来，我们来实现热更新的功能，实现热更新，需要配合 webpack 提供的一个 叫 HotModuleReplacementPlugin 的模块，我们需要在 devServer 中配置 hot 为 true 、并且引入 webpack，然后在 plugins 中实例化这个函数。代码如下：\r\n\r\n```diff\r\n+ const webpack = require("webpack");\r\n// 引入这个插件，在最新版本中，它不在返回一个函数，而是返回一个对象，我们需要进行结构操作。\r\nconst { merge } = require("webpack-merge");\r\n// 引入我们抽离出来的公共模块\r\nconst common = require("./webpack.common");\r\n// 合拼 common ，并且编写新的内容，覆盖原基础文件\r\nmodule.exports = merge(common, {\r\n  mode: "development", // 设置为 development 觅食\r\n  devtool: "cheap-eval-module-source-map", // 开启source-map\r\n  devServer: {\r\n    // 启动服务器\r\n    host: "localhost", // 主机地址\r\n    port: "6060", // 端口\r\n    open: true, // 是否自动打开浏览器\r\n+   hot: true, // 开启热更新\r\n    contentBase: "public", // 告诉服务器从public目录提供静态文件\r\n  },\r\n+ plugins: [new webpack.HotModuleReplacementPlugin()],\r\n});\r\n```\r\n\r\n接着，我们重新启动服务，输入 `yarn webpack-dev-server --open --config webpack.dev.js`，服务启动后，我们修改一下 App.vue 这个文件，修改一下 msg 这个属性，我们点击保存，回到浏览器，页面内容已经修改成了我们修改后的内容了，这就证明热更新是没有问题的。 效果如下：\r\n\r\n<video src="https://raw.githubusercontent.com/Aisen-cai/Test/master/webpack-dev-server.mov" controls="controls" width="1000" height="600">您的浏览器不支持播放该视频！</video>\r\n\r\n视频的地址是：https://raw.githubusercontent.com/Aisen-cai/Test/master/webpack-dev-server.mov\r\n\r\n## 处理打包上线\r\n\r\n接下来，我们来处理最后的任务，编写打包上线的编译模块的内容。这个流程我们需要用到 clean-webpack-plugin、copy-webpack-plugin 这两个插件，clean-webpack-plugin 帮助我们自动清除目录，copy-webpack-plugin 帮助我们拷贝一些文件到指定目录。\r\n\r\n在控制台输入 `yarn add clean-webpack-plugin copy-webpack-plugin --dev`来安装。安装完成后，编写以下代码：\r\n\r\nwebpack.prod.js\r\n\r\n```javascript\r\nconst path = require("path");\r\n// 引入这个插件，在最新版本中，它不在返回一个函数，而是返回一个对象，我们需要进行结构操作。\r\nconst { merge } = require("webpack-merge");\r\n// 引入我们抽离出来的公共模块\r\nconst commmon = require("./webpack.common");\r\n// 引入 clean-webpack-plugin，它的实例方法是个对象，我们需要结构操作。\r\nconst { CleanWebpackPlugin } = require("clean-webpack-plugin");\r\n// 引入 copy-webpack-plugin\r\nconst copyPlugin = require("copy-webpack-plugin");\r\n// 合拼 common ，并且编写新的内容，覆盖原基础文件\r\nmodule.exports = merge(commmon, {\r\n  mode: "production", // 设置为production模式\r\n  output: {\r\n    filename: "bundle.js", // 打包过后的js文件名\r\n    path: path.resolve(__dirname, "dist"), // 输出的目录\r\n  },\r\n  plugins: [new CleanWebpackPlugin(), new copyPlugin(["public"])],\r\n});\r\n```\r\n\r\n编写完毕过后，我们在终端输入 `yarn webpack --config webpack.prod.js`进行编译，稍等一会，编译完成后，我们在根目录下会出现一个 dist 目录，我们打开 dist 目录下的每个文件，来看看编译过后是什么样子的。我们打开到 bundle.js，我们可以看到代码已经被压缩了，我们可以启动一个服务器，来看看是否打包过后的内容是否可运行。\r\n\r\n## 优化\r\n\r\n至此，我们所有的任务都已经完成了。我们接下来，来优化一下，我们每当启动服务器或者打包的时候，都要输入一大串命令，闲得很麻烦，我们可以在 package.json 中写 script 脚本。代码如下：\r\n\r\npackage.json\r\n\r\n```diff\r\n+ "scripts": {\r\n+   "serve": "webpack-dev-server --open --config webpack.dev.js",\r\n+   "build": "webpack --config webpack.prod.js",\r\n+   "lint": "eslint --ext .js,.vue src"\r\n+ },\r\n```\r\n\r\n这样，我们就不需要输入这么多繁琐的命令了。\r\n\r\n至此，所有的任务都已经完成了，有错误或者不明白的地方，可以在下面提出，欢迎纠正，谢谢~',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/14',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/14/labels{/name}',
    comments_url:
      'https://api.github.com/repos/Aisen60/blog/issues/14/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/14/events',
    html_url: 'https://github.com/Aisen60/blog/issues/14',
    id: 652417921,
    node_id: 'MDU6SXNzdWU2NTI0MTc5MjE=',
    number: 14,
    title: 'ES Module 开发阶段浏览器环境兼容方案',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-07-07T15:29:51Z',
    updated_at: '2020-07-07T15:36:25Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '目前主流的浏览器都兼容  `ES Module`  了，但是，可恶的  `IE` 在最新的版本中还不支持，为了兼容，我们可以通过下面这个三个包来解决，主要的代码如下：\r\n\r\n**Index.html**\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang="en">\r\n\r\n<head>\r\n    <meta charset="UTF-8">\r\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\r\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\r\n    <title>ES Module 浏览器环境 Polyfill</title>\r\n</head>\r\n\r\n<body>\r\n\r\n    <!-- \r\n        引用下面这三个包，解决浏览器对 ES Module 的兼容\r\n        最新的ie还是不兼容 prmise 要引入 promise-polyfill 这个插件来兼容\r\n        然后要引入下面两个包就可可以了\r\n        思路是：browser-es-module-loader 会去读取 ES Module 的代码，然后通过babel去转换\r\n\r\n        如果在支持 ES Module 的浏览器中，代码会被执行两次，我们可以在 script 标签上，加一个 nomodule 来表示，只在不支持 ES Module 的浏览器上加载下面的这三个包\r\n     -->\r\n    <script nomodule src="https://unpkg.com/promise-polyfill@8.1.3/dist/polyfill.min.js"></script>\r\n    <script nomodule src="https://unpkg.com/browser-es-module-loader@0.4.1/dist/babel-browser-build.js"></script>\r\n    <script nomodule src="https://unpkg.com/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js"></script>\r\n    <script type="module">\r\n        import { foo } from \'./module.js\'\r\n        console.log(foo)\r\n    </script>\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n\r\n\r\n**module.js**\r\n\r\n```javascript\r\nexport var foo = "bar";\r\n```\r\n\r\n**这种方案，只适合在开发阶段使用。在生产阶段不要使用这种方案，因为它的原理都是在运行阶段动态的解析脚本，那效率会非常的差！！！在生产阶段，我们应该预先把这些代码编译好，让这些代码可以直接在浏览器上工作。**',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/13',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/13/labels{/name}',
    comments_url:
      'https://api.github.com/repos/Aisen60/blog/issues/13/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/13/events',
    html_url: 'https://github.com/Aisen60/blog/issues/13',
    id: 651100258,
    node_id: 'MDU6SXNzdWU2NTExMDAyNTg=',
    number: 13,
    title: '使用 gulp 进行项目的开发和打包',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1721385519,
        node_id: 'MDU6TGFiZWwxNzIxMzg1NTE5',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/good',
        name: 'good',
        color: 'ae8a53',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-07-05T16:23:16Z',
    updated_at: '2020-07-06T16:44:21Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '# 使用 gulp 进行项目的开发和打包\r\n\r\n## 目标\r\n\r\n使用 gulp 提供一个在项目的开发过程中需要的服务器，热更新的功能。在项目开发完成后，编译压缩合拼文件，通过命令的方式帮助我们自动完成编译构建。\r\n\r\n## 说明\r\n\r\n文档中使用到的模板是这个：[aisen60-pages](https://github.com/Aisen60/aisen60-pages)\r\n\r\n## gulp 是什么？\r\n\r\n引用官网的一句话**gulp 将开发流程中让人痛苦或耗时的任务自动化，从而减少你所浪费的时间、创造更大价值。**，gulp 是一个自动化的工具，它可以帮助我们完成很多耗时重复的任务，例如：编译、打包、压缩等等。gulp 本身不具备任务的打包编译压缩的功能，它只是一个任务工具，我们可以通过插件，编写任务的方式实现我们想要的想要自动化构建的内容。\r\n\r\n## 准备工作\r\n\r\n### 安装 gulp\r\n\r\n克隆或者下载模板到本地，执行`yarn install`安装项目所需要的依赖。安装完依赖后，我们来安装 gulp。输入`yarn add gulp --dev`，就能完成 gulp 的安装。安装完成后，我们需要在根目录下新建一个**gulpfile.js**的文件，这个文件是 gulp 的入口文件。我们所有的任务都在这个文件进行编写。我们需要通过`module.exports`的方式导出任务。代码如下：\r\n\r\n```javaScript\r\nmodule.exports = {\r\n  clean,\r\n};\r\n```\r\n\r\n**在 gulp 中，可以理解为，一个任务就是一个函数，或者一个任务是由多个任务组合成函数的。**\r\n\r\n### 安装 gulp-load-plugins\r\n\r\n安装完 gulp 过后，我们来安装一个`gulp-load-plugins`这个插件，这个插件就是帮我们去自动加载所有的插件的，这样的话，就不需要一个一个引入了。我们在命令行终端输入`yarn add gulp-load-plugins --dev`来安装这个插件。\r\n\r\n安装完成后，我们在 gulpfile.js 中引入，并且调用它。\r\n\r\n```javaScript\r\nconst loadPlugins = require("gulp-load-plugins");\r\n\r\nconst plugins = loadPlugins();\r\n```\r\n\r\n### 项目中会用到的 gulp 的 api\r\n\r\n接着，我们来看看 gulp 中几个常用的 api。点击进入[官方文档](https://www.gulpjs.com.cn/docs/api/)\r\n\r\n- `src` 是 gulp 提供的一个读取流 api\r\n- `dest` 是 gulp 提供的一个写入流 api\r\n- `watch` 是一个 gulp 提供的一个监听文件变化的 api\r\n- `series`是 gulp 提供的一个函数组合任务函数，它会按照顺序依次执行任务，可以称为串行任务\r\n- `parallel` 是 gulp 提供的一个函数组合任务函数，它和 series 的功能是一样的，但是没有执行循序的限制，可以称为并行任务\r\n\r\n以上这几个 api，会经常用到。\r\n\r\n## 编写基础任务\r\n\r\n准备工作完成后，我们来编写基础任务。编写基础任务，主要是处理这几个方面的内容：\r\nhtml 的处理、scss 文件的处理，es6 的编译，以及图片文件、字体和一些其他文件的处理。\r\n\r\n这些基础任务，在后面的开发服务器和打包压缩都会使用到。\r\n\r\n### 清除任务的编写\r\n\r\n因为在开发服务器以及最后的打包构建环节，会经常对文件夹进行删除操作，一般我们编译上线都是 `dist` 目录。我们在开发服务器时，会监听一个 `temp` 目录。所以这里，我们会写一个清除任务，对 `dist` 和 `temp` 这两个文件夹进行删除操作。\r\n\r\n那，完成这个删除操作，需要安装一个`del`的包。我们在命令行输入 `yarn add del --dev` 来完成安装。安装完成后，我们在 gulpfile.js 中引入 `del` 这个包，并且编写清除任务。代码如下：\r\n\r\n```javaScript\r\nconst del = require("del");\r\n\r\n/**\r\n * 清除目录\r\n */\r\nconst clean = () => {\r\n  return del(["temp", "dist"]);\r\n};\r\n\r\nmodule.exports = {\r\n  clean,\r\n};\r\n```\r\n\r\n编写完任务后，我们在根目录下手动新建一个 dist 目录和 temp 目录。然后在命令行终端输入：`yarn gulp clean`,输入完命令后，我们可以看到，终端会输出一些信息（开始任务，结束任务，耗时，完成等情况），在看看根目录下，dist 和 temp 文件夹已经被删除了。\r\n\r\n我们的第一个基础的任务就已经编写完成了。\r\n\r\n### 处理 html\r\n\r\n因为后面我们需要去启动一个服务器渲染我们的页面，一般情况下，我们会监听一个叫做 temp 为文件夹，这个 temp 文件夹就是服务器所需要渲染和加载的内容。\r\n\r\n我们先处理 html 的内容，我们打开到 index.html 这个文件，我们观察一下这个 index.html 引入了 main.css、 main.js 和 node_module 中的 bootstrap.css、jquery.js、popper.js、bootstrap.js。这些我们都暂时先不管，后面会有专门的处理。\r\n\r\n现在要做的内容就是，将 src 下的 index.html 和 about.html 拷贝到 temp 文件夹下。\r\n\r\n我们来编写代码：\r\n\r\n```JavaScript\r\n/**\r\n * 处理html\r\n * 读取src文件夹下的所有的以html结尾的文件，写入到temp文件夹下\r\n */\r\nconst page = () => {\r\n  return src("src/*.html", { base: "src" }).pipe(dest("temp"));\r\n};\r\n```\r\n\r\n**这段代码的意思是，使用 gulp 提供的 src 这个 api，去读取 src 文件夹下的所有的以 html 结尾的文件，使用 gulp 提供的 dest 这个 api 写入到 temp 文件夹下。**\r\n\r\n我们需要把 page 这个函数导出，导出过后，我们在命令行终端输入`yarn gulp page` 。输入过后，我们会看到，根目录下会多出一个 temp 文件夹，我们打开 temp 文件夹会看到里面有一个 index.html 和 about.html 文件，这两个文件的内容都是和 src 下的内容是一致的。\r\n\r\n### 处理 scss\r\n\r\n那接下来，我们来处理 temp 文件夹下 index.html 和 about.html 中的 main.css。我们在 src 文件夹下找到 main.scss 文件，因为浏览器是识别不了 scss 文件的，我们需要将 scss 编译成 css，供浏览器使用。我们需要将 main.scss 编译成 main.css 然后按照指定目录层级的关系，写入到 temp 目录中。\r\n\r\n在这个过程中，要使用到一个插件，叫做 `gulp-sass`。在命令行终端输入 `yarn add gulp-sass --dev`，安装完成过后，我们来编写以下处理 scss 这个任务，代码如下：\r\n\r\n```JavaScript\r\n/**\r\n * scss文件的处理\r\n * 读取src目录下的assets目录下的styles目录下的所有的以scss结尾的文件，使用sass这个插件把scss编译成css,并且写入到temp目录下。\r\n */\r\nconst style = () => {\r\n  return (\r\n    src("src/assets/styles/*.scss")\r\n      // 因为使用了sass，需要安装gulp-sass这个插件处理sass，\r\n      /**\r\n       * 参数说明：\r\n       * outputStyle 输出的样式风格。\r\n       * 有以下几种方式：\r\n       * 嵌套输出方式 nested\r\n       * 展开输出方式 expanded\r\n       * 紧凑输出方式 compact\r\n       * 压缩输出方式 compressed\r\n       */\r\n      .pipe(plugins.sass({ outputStyle: "expanded" }))\r\n      .pipe(dest("temp"))\r\n  );\r\n};\r\n```\r\n\r\n编写完后，我们还需要将 style 导出出去，方便我们校验测试。接着，我们在命令行终端输入 `yarn gulp style` 这个命令。完了之后，我们观察一下 temp 目录下会多出一个 main.css 文件。我们打开这个 main.css 文件，我们看到这里面的内容已经是 css 的内容了。\r\n\r\n**这时你或许有疑问了 🤔🤔🤔**\r\n\r\n**为什么 src 目录的 style 目录有三个.scss 文件，而编译后的只有一个 main.css？**\r\n\r\n**为什么写入 temp 目录时，没有和 src 目录下一样的结构？**\r\n\r\n那，针对第一个问题呢，其实原因很简单，我们打开到 src 下的 main.scc,我们可以看到引入了\\_icons.scss 和 \\_variables.scss，而一般，文件名以下划线开头的都是引用文件。在编译的时候，会把内容写入到一起\r\n\r\n第二个问题呢，解决的方法就是，在 src 这个 api 设置一个 base 的基本路径，设置成\'src\'就能解决这个问题。代码如下：\r\n\r\n```diff\r\n/**\r\n * scss文件的处理\r\n * 读取src目录下的assets目录下的styles目录下的所有的以scss结尾的文件，使用sass这个插件把scss编译成css,并且写入到temp目录下。\r\n */\r\nconst style = () => {\r\n  return (\r\n-    src("src/assets/styles/*.scss")\r\n+    src("src/assets/styles/*.scss", { base: "src" })\r\n      // 因为使用了sass，需要安装gulp-sass这个插件处理sass，\r\n      /**\r\n       * 参数说明：\r\n       * outputStyle 输出的样式风格。\r\n       * 有以下几种方式：\r\n       * 嵌套输出方式 nested\r\n       * 展开输出方式 expanded\r\n       * 紧凑输出方式 compact\r\n       * 压缩输出方式 compressed\r\n       */\r\n      .pipe(plugins.sass({ outputStyle: "expanded" }))\r\n      .pipe(dest("temp"))\r\n  );\r\n};\r\n```\r\n\r\n我们重新执行一下 `yarn gulp style` 这个任务，可以看到，temp 目录下生成的 main.css 已经是按照和 src 目录下一模一样的层级结构了。\r\n\r\n### js 的处理\r\n\r\n接下来，我们继续来处理 js，我们打开 src 下的 main.js，我们能看到使用了 es6 定义变量的关键词，在现代浏览器中，大部分的浏览器对 es6 的兼容比较差，我们需要借助 babel 将 es6 以及以上的版本进行编译，转换成浏览器可使用的 es5 代码等。\r\n\r\n接下来，我们需要安装`gulp-babel`、`@babel/core`、`@babel/preset-env` 这三个插件。我们在命令行输入`yarn add gulp-babel @babel/core @babel/preset-env --dev`。安装完成后，我们来编写任务，代码如下：\r\n\r\n```JavaScript\r\n/**\r\n * js文件的处理\r\n * 读取src目录下的assets目录下的scripts目录下的所有的以js结尾的文件，使用babel这个插件并且使用"@babel/preset-env"这个规则，\r\n * 把代码中es6及以上版本的新特性，编译成es5,并且写入到temp目录下。\r\n */\r\nconst script = () => {\r\n  return (\r\n    src("src/assets/scripts/*.js", { base: "src" })\r\n      // 需要安装babel对js进行处理，需要安装gulp-babel @babel/core @babel/preset-env 这3个插件\r\n      .pipe(plugins.babel({ presets: ["@babel/preset-env"] }))\r\n      .pipe(dest("temp"))\r\n  );\r\n};\r\n```\r\n\r\n编写完代码后，我们要把 script 导出，方便我们校验测试。\r\n\r\n接着，我在浏览器控制台，输入 `yarn gulp script` 来执行这个任务，**执行完后，我们看到 temp 目录下的 assets 目录下的 scripts 目录，里面有一个 main.js 文件，证明，我们输出写入的层级关系和 src 目录下是一致的。我们打开 temp 目录下的 main.js 文件，可以看到原 src 目录下的 main.js 所使用的 `const` 变量关键字，已经修改成了浏览器可识别的 `var`**\r\n\r\n编写完对 html、css、js 文件的处理后，我们还需要编写三个任务，这三个任务分别是图片文件的处理、字体文件的处理、还有其他文件的处理。这三个任务在启动一个服务器时不会用到，但是我们在最后的打包编译时会用得到。\r\n\r\n### 图片文件的处理\r\n\r\n接着，我们来处理一下图片文件。会使用到一个插件叫做`gulp-imagemin`，这个插件的主要作用就是帮助我们高保真的压缩图片或者文件。它是不会损坏原文件或者原图片的，它会在保持原文件或者原图片的情况下，尽可能的压缩文件的大小。\r\n\r\n我们在终端输入`yarn add gulp-imagemin --dev` 来安装一下这个插件。PS:这个插件使用 yarn 会非常慢，因为要去下载一些二进制的东西。所以我这里用了 cnpm 去安装。安装完了之后，我们开始编写任务，代码如下：\r\n\r\n```JavaScript\r\n/**\r\n * 处理图片\r\n * 读取src目录下的assets目录下的images目录下的所有文件，使用imagemin这个插件进行高保真的压缩,并且写入到dist目录下。\r\n */\r\nconst image = () => {\r\n  return src("src/assets/images/**", { base: "src" })\r\n    .pipe(plugins.imagemin())\r\n    .pipe(dest("dist"));\r\n};\r\n```\r\n\r\n编写完代码后，我们要把 image 导出，方便我们校验测试。我们在终端输入 `yarn gulp image` 来执行以下这个任务，需要花的时间可能会比较久。压缩完成过后，我们看到 temp 目录下的 assets 目录下已经有 src 目录下的那张图片了。为了校验是否有压缩成功，我们首先查看 src 目录下的 logo.png 文件的大小是**545KB**,在看到 dist 目录下的 logo.png 文件的大小是**312KB**。那就证明是压缩了的。\r\n\r\n### 字体文件的处理\r\n\r\n同样的，字体文件的处理也可以使用 imagemin 这个插件来处理，代码如下：\r\n\r\n```javaScript\r\n/**\r\n * 处理图片\r\n * 读取src目录下的assets目录下的fonts目录下的所有文件，使用imagemin这个插件进行高保真的压缩,并且写入到dist目录下。\r\n */\r\nconst font = () => {\r\n  return src("src/assets/fonts/**", { base: "src" })\r\n    .pipe(plugins.imagemin())\r\n    .pipe(dest("dist"));\r\n};\r\n```\r\n\r\n编写完代码后，我们要把 font 导出，方便我们校验测试。我们在终端输入 `yarn gulp font` 来执行以下这个任务。任务执行成功后，我们可以比较 src 下的 fonts 下的文件大小与 dist 下的 fonts 下的文件大小的差异。\r\n\r\n### 其他文件的处理\r\n\r\n我们在编写一个任务，这个任务是去处理一些其他文件的，比如说网站的 ico 图标等等，同样的，我们也可以使用\r\nimagemin 这个插件，代码如下：\r\n\r\n```javaScript\r\n/**\r\n * 其他文件的处理\r\n */\r\nconst extra = () => {\r\n  return src("public/**", { base: "public" })\r\n    .pipe(plugins.imagemin())\r\n    .pipe(dest("dist"));\r\n};\r\n```\r\n\r\n编写完代码后，我们要把 extra 导出，方便我们校验测试。我们在终端输入 `yarn gulp extra` 来执行以下这个任务。任务执行成功后，我们可以看到 dist 目录下多了 favicon.ico 这个文件。\r\n\r\n### image、font、extra 任务的其他说明\r\n\r\n为什么我要把 image、font、extra 这三个任务写入到 dist 目录呢？因为这三个任务都是比较耗时的，在开发阶段中没有必要把这三个耗时的任务也一起处理了。那关于 temp 目录要如何引用这图片、字体以及 ico 呢？下面的开发服务器会有讲解。\r\n\r\n## 启动一个服务器\r\n\r\n### 安装 grunt-browser-sync 插件\r\n\r\n接下里，我们来实现，启动一个服务器，并且实现热更新的功能。要想启动一个服务器，我们还需要借助一个插件，叫做`browser-sync`，我们来安装一下这个插件。命令行输入`yarn add browser-sync --dev`。安装完成过后，我们需要在 gulpfile.js 中引入这个插件，并且调用这个插件的`create`方法来创建一个实例。代码如下：\r\n\r\n```JavaScript\r\nconst browserSync = require("browser-sync");\r\nconst bs = browserSync.create();\r\n```\r\n\r\n接下来，我们来编写任务，代码如下：\r\n\r\n```JavaScript\r\n/**\r\n * 创建开发服务器，实现热更新功能。\r\n */\r\nconst serve = () => {\r\n  bs.init({\r\n    notify: false, //是否通知\r\n    port: 6060, //启动的端口，默认3000端口\r\n    server: {\r\n      baseDir: ["temp"],\r\n    },\r\n  });\r\n};\r\n```\r\n\r\n这段代码的意思是，通过 browser-sync 中 init 这个方法来创建一个服务器。参数的讲解\r\n\r\n- notify 是否开启通知，\r\n- port 启动的端口，默认 3000 端口。\r\n- server\r\n  - baseDir 是监听的目录。\r\n\r\n写完任务后，我们先把 serve 导出出去。但是这里会有一个问题，在执行这个任务之前我们要处理根目录下没有 temp 目录的情况。那我们想想，temp 目录下存放的是什么？是不是存放的我们前面写的 page、style、script 这几个任务所生成文件。\r\n\r\n所以我们在执行 serve 这个任务之前，我们要重新执行 page、style、script 这个几个任务。那我们肯定不想一个一个任务手动执行，我们可以使用 gulp 提供的一个 api，叫做`parallel`,它的作用是，将几个任务串联在一起执行，没有顺序之分。代码如下：\r\n\r\n```diff\r\n- const { src, dest } = require("gulp");\r\n+ const { src, dest, parallel } = require("gulp");\r\n```\r\n\r\n```JavaScript\r\nconst compile = parallel(page, style, script);\r\n```\r\n\r\n编写完这个 `compile` 任务后，我们要把 `compile` 导出,方便我们校验测试。我们先手动把根目录下 temp 目录删除，接着我们在终端输入`yarn gulp compile` 执行完后，我们可以看到根目录下重新生成了 temp 目录，temp 目录下有 `page, style, script` 这三个任务所输出的文件。\r\n\r\n接着，我们在命令终端输入 `yarn gulp serve` 这个命令，系统会自动帮我们打开一个浏览器，并且是 6060 端口的。\r\n\r\n我们先来看看有什么效果，效果如下：\r\n\r\n<img  alt="https://user-images.githubusercontent.com/19791710/86598686-0ec33b80-bfd0-11ea-8ab3-412734a1a12a.png" src="https://user-images.githubusercontent.com/19791710/86598686-0ec33b80-bfd0-11ea-8ab3-412734a1a12a.png">\r\n\r\n我们看到页面的样式完全是乱的。为了解决这个问题，我们打开到 temp 目录下的 index.html 文件，我们发现 index.html 中 head 标签中使用了一个 node_module 的 bootstrap.css。而我们的服务器是监听 temp 目录的，我们 temp 目录下并没有 node_module 这个文件夹。那要如何解决这个问题，难道要把 node_module 拷贝到 temp 目录下嘛？这样有点不现实。\r\n\r\n为了解决这个问题，我们可以在 bs.init 中加入一个配置，叫做 `routes`，路由映射，它会优先去我们指定的目录查找文件，代码如下：\r\n\r\n```diff\r\n/**\r\n * 创建开发服务器，实现热更新功能。\r\n */\r\nconst serve = () => {\r\n  bs.init({\r\n    notify: false, //是否通知\r\n    port: 6060, //启动的端口，默认3000端口\r\n    server: {\r\n      baseDir: ["temp"],\r\n+       routes: {\r\n+         // 前置路由，设置了路由后，会去找项目目录中指定的文件夹\r\n+         "/node_modules": "node_modules",\r\n+       },\r\n    },\r\n  });\r\n};\r\n```\r\n\r\n添加了之后，我们重新运行 `yarn gulp serve` ，我们可以看到现在页面样式已经是正常的了。\r\n\r\n效果如下：\r\n\r\n<img alt="https://user-images.githubusercontent.com/19791710/86600345-84c8a200-bfd2-11ea-9a51-c77903271272.png" src="https://user-images.githubusercontent.com/19791710/86600345-84c8a200-bfd2-11ea-9a51-c77903271272.png">\r\n\r\n我们打开 F12，切换到 Network 选择 CSS，我们可以看到已经 bootstrap.css 已经是加载成功了。在选择到 JS，我们也可以看到 bootstrap.js、jquery.js、popper.js 都是已经加载进来了。\r\n\r\n接下来，我们随便点点页面上的按钮看看，我们点导航中的 About 按钮，进入到 about.html 页面，我们发现 logo 没有加载出来，效果图如下：\r\n\r\n<img alt="https://user-images.githubusercontent.com/19791710/86603991-5dc09f00-bfd7-11ea-803c-2c03a394e4b0.png" src="https://user-images.githubusercontent.com/19791710/86603991-5dc09f00-bfd7-11ea-803c-2c03a394e4b0.png">\r\n\r\n我们打开 F12，找到这个图片元素，我们发现，它引用的是当前目录下的 assets 目录下的 images 目录下 logo.png，可是我们的 temp 目录下没有啊。前面说过了，我们在开发阶段不需要把图片字体和其他文件一起打包到 temp 目录下，我们可以通过监听多个目录的方式来解决这个问题。代码如下：\r\n\r\n```diff\r\n/**\r\n * 创建开发服务器，实现热更新功能。\r\n */\r\nconst serve = () => {\r\n  bs.init({\r\n    notify: false, //是否通知\r\n    port: 6060, //启动的端口，默认3000端口\r\n    server: {\r\n-      baseDir: ["temp"],\r\n+      baseDir: ["temp", "src", "public"], // 监听多个目录\r\n      routes: {\r\n        // 前置路由，设置了路由后，会去找项目目录中指定的文件夹\r\n        "/node_modules": "node_modules",\r\n      },\r\n    },\r\n  });\r\n};\r\n```\r\n\r\n我们重新执行一下 `yarn gulp serve`，在重新进入 about 页面，我们看到，图片 logo 已经加载进来了。\r\n\r\n### 简化步骤\r\n\r\n接下来，我们观察一下，难道启动一个服务器把项目跑起来要手动删除 temp 目录并且执行两条任务嘛？我们能不能编写一个任务，先去执行 `clean` 任务，接着执行 `compile` 最后再去执行 `serve` 任务。\r\n\r\n当然是可以的了，我们可以使用 gulp 提供中的一个 api 叫做`series`，它是一个函数组合任务函数，它和 parallel 一样可以一次执行多个任务，但是，它会按照顺序依次执行任务，可以称为串行任务。\r\n\r\n代码如下：\r\n\r\n```diff\r\n- const { src, dest, parallel } = require("gulp");\r\n+ const { src, dest, parallel, series } = require("gulp");\r\n```\r\n\r\n```JavaScript\r\nconst develop = series(clean, compile, serve);\r\n```\r\n\r\n编写完后，我们需要把 `develop` 导出出去，方便我们校验调试。\r\n\r\n我们在命令行终端输入 `yarn gulp develop` ，执行完任务后，系统会帮我们打开一个浏览器，我们随点点点、看看页面的内容展示是否完善。\r\n\r\n这样就完成了服务器的启动。\r\n\r\n### 实现热更新\r\n\r\n我们需要使用到 gulp 提供的一个 api 叫做 `watch` 搭配 `browser-sync` 一起使用来实现热更新。\r\n\r\n我们需要引入 `watch`，代码如下：\r\n\r\n```diff\r\n- const { src, dest, parallel, series } = require("gulp");\r\n+ const { src, dest, parallel, series, watch } = require("gulp");\r\n```\r\n\r\n接着，我们修改一下 `serve` 任务，代码如下：\r\n\r\n```diff\r\n/**\r\n * 创建开发服务器，实现热更新功能。\r\n */\r\nconst serve = () => {\r\n+ watch("src/*.html", page); // 监听src目录下的所有html文件，当文件发生变化时，执行page这个任务\r\n+ watch("src/assets/styles/*.scss", style); // 监听src目录下的assets目录下的styles目录下的所有scss文件，当文件发生变化时，执行style这个任务\r\n+ watch("src/assets/scripts/*.js", script); // 监听src目录下的assets目录下的script目录下的所有scss文件，当文件发生变化时，执行script这个任务\r\n+ // 监听src/assets/images、src/assets/fonts、和public目录下的所有内容，执行 bs.reload 这个方法，重新加载\r\n+ watch(\r\n+   ["src/assets/images/**", "src/assets/fonts/**", "public/**"],\r\n+   bs.reload\r\n+ );\r\n  bs.init({\r\n    notify: false, //是否通知\r\n    port: 6060, //启动的端口，默认3000端口\r\n    server: {\r\n      baseDir: ["temp", "src", "public"], // 监听多个目录\r\n      routes: {\r\n        // 前置路由，设置了路由后，会去找项目目录中指定的文件夹\r\n        "/node_modules": "node_modules",\r\n      },\r\n    },\r\n  });\r\n};\r\n```\r\n\r\n在接着，我们还要修改 `page, style, script` 这三个任务，代码如下：\r\n\r\n```diff\r\n/**\r\n * 处理html\r\n * 读取src文件夹下的所有的以html结尾的文件，写入到temp文件夹下\r\n */\r\nconst page = () => {\r\n  return src("src/*.html", { base: "src" })\r\n    .pipe(dest("temp"))\r\n+   .pipe(bs.reload({ stream: true }));// 当watch执行这个任务的时候，重新加载这个任务\r\n};\r\n\r\n/**\r\n * scss文件的处理\r\n * 读取src目录下的assets目录下的styles目录下的所有的以scss结尾的文件，使用sass这个插件把scss编译成css,并且写入到temp目录下。\r\n */\r\nconst style = () => {\r\n  return (\r\n    src("src/assets/styles/*.scss", { base: "src" })\r\n      // 因为使用了sass，需要安装gulp-sass这个插件处理sass，\r\n      /**\r\n       * 参数说明：\r\n       * outputStyle 输出的样式风格。\r\n       * 有以下几种方式：\r\n       * 嵌套输出方式 nested\r\n       * 展开输出方式 expanded\r\n       * 紧凑输出方式 compact\r\n       * 压缩输出方式 compressed\r\n       */\r\n      .pipe(plugins.sass({ outputStyle: "expanded" }))\r\n      .pipe(dest("temp"))\r\n+     .pipe(bs.reload({ stream: true }));// 当watch执行这个任务的时候，重新加载这个任务\r\n  );\r\n};\r\n\r\n/**\r\n * js文件的处理\r\n * 读取src目录下的assets目录下的scripts目录下的所有的以js结尾的文件，使用babel这个插件并且使用"@babel/preset-env"这个规则，\r\n * 把代码中es6及以上版本的新特性，编译成es5,并且写入到temp目录下。\r\n */\r\nconst script = () => {\r\n  return (\r\n    src("src/assets/scripts/*.js", { base: "src" })\r\n      // 需要安装babel对js进行处理，需要安装gulp-babel @babel/core @babel/preset-env 这3个插件\r\n      .pipe(plugins.babel({ presets: ["@babel/preset-env"] }))\r\n      .pipe(dest("temp"))\r\n+     .pipe(bs.reload({ stream: true }))// 当watch执行这个任务的时候，重新加载这个任务\r\n  );\r\n};\r\n```\r\n\r\n**修改的这几段代码的意思是，在`serve`这个任务中去监听这些文件，并且执行相关的任务和重新加载**\r\n\r\n- src/\\*.html\r\n- src/assets/styles/\\*.scss\r\n- src/assets/scripts/\\*.js\r\n- src/assets/images/\\*\\*\r\n- src/assets/fonts/\\*\\*\r\n- public/\\*\\*\r\n\r\n修改完后，我们重新执行 `yarn gulp develop` 这个任务，当浏览器启动完成后，我们修改首页 banner 这个样式，就是修改 src 下的\\_variables.scss 文件，我们修改`$jumbotron-bg`这个变量，我们改成红色（#f00），修改完成后，我们保存，切换回浏览器，我们可以看到页面时时时更新的，效果如下：\r\n\r\n<img  alt="https://user-images.githubusercontent.com/19791710/86609587-b21b4d00-bfde-11ea-9f2d-43f54fd7b31d.png" src="https://user-images.githubusercontent.com/19791710/86609587-b21b4d00-bfde-11ea-9f2d-43f54fd7b31d.png">\r\n\r\n至此，我们热更新已经做完了。\r\n\r\n## 上线时的处理\r\n\r\n### 使用 useref\r\n\r\n我们在打包上线时，需要借助一个插件来帮我处理代码中一些 node_module 的文件引用、合拼和压缩，叫做`gulp-useref`，同时我们需要安装 `gulp-htmlmin` 这个插件来帮助我们压缩 html 代码、`gulp-clean-css` 这个插件来帮助我们压缩 css 代码、`gulp-uglify` 这个插件来帮助我们压缩 js 代码。还要安装一个插件，`gulp-if` 我们可以通过这个插件来判断是什么类型的文件，去执行相对应的处理。\r\n\r\n我们在终端输入安装命令，`yarn add gulp-useref gulp-if gulp-htmlmin gulp-clean-css gulp-uglify --dev` ps：用 yarn 安装好像会比较慢，又要去下载二进制的东西，我这里用了 cnpm 安装。\r\n\r\n安装完成后，我们来编写任务，代码如下：\r\n\r\n```JavaScript\r\n/**\r\n * 处理打包上线时，代码中一些node_module的文件引用、合拼和压缩\r\n * 需要借助一个叫做 gulp-useref 的插件\r\n */\r\nconst useref = () => {\r\n  /**\r\n   * 这里会有一个问题，因为这里同时对一个目录读取和写入，可能会有冲突，可以通过新建一个目录来存放原本dist文件夹的内容，叫做temp文件夹\r\n   * 再接着，通过读取temp文件夹的内容，写入到dis文件夹中就不会有问题。\r\n   */\r\n  return (\r\n    src("temp/*.html", { base: "temp" })\r\n      .pipe(plugins.useref({ searchPath: ["temp", "."] }))\r\n      // 这里对html,css,js文件进行压缩操作\r\n      // 因为这里需要同时处理html,css,js文件，需要安装一个叫做 gulp-if 的插件来判断是什么文件\r\n      // 同理也要安装一些压缩的插件，html->gulp-htmlmin css->gulp-clean-css js->gulp-uglify\r\n      .pipe(\r\n        plugins.if(\r\n          // 使用gulp-if这个插件判断是什么类型的文件，如果是html文件，执行htmlmin这个插件\r\n          /\\.html$/,\r\n          plugins.htmlmin({\r\n            collapseWhitespace: true, // 压缩一行不留空格\r\n            minifyCSS: true, // css也是压缩成一行\r\n            minifyJS: true, // js也是压缩成一行\r\n          })\r\n        )\r\n      )\r\n      .pipe(plugins.if(/\\.css$/, plugins.cleanCss())) // 使用gulp-if这个插件判断是什么类型的文件，如果是html文件，执行cleanCss这个插件\r\n      .pipe(plugins.if(/\\.js$/, plugins.uglify())) // 使用gulp-if这个插件判断是什么类型的文件，如果是html文件，执行uglify这个插件\r\n      .pipe(dest("dist")) // 将处理完过后的内容，全部输入到\r\n  );\r\n};\r\n```\r\n\r\n编写完后，我们需要将 useref 这个任务导出，方便我们校验调试。我们在命令行终端，输入 `yarn gulp useref` 稍等一会，等任务执行结束后，我们看到 dist 目录下的已经生成了和 temp 目录下的内容是一致的了，我们打开 index.html 这个文件，我们发现已经被压缩成一行了，我们在看看 css 和 js 文件，都已经是被压缩成一行了。\r\n\r\n我们打开 dist 文件夹下的 index.html，通过编辑器将代码格式化。再接着我们打开 temp 目录下的 index.html，我们来对比一下这两个文件。\r\n\r\n我们发现，temp 文件夹下的 index.html 中 head 标签是这样的\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/86614216-3e307300-bfe5-11ea-82a5-cf05aa1aa3a1.png)\r\n\r\n而，dist 文件夹下的 index.html 中 head 标签是这样的，\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/86614105-16410f80-bfe5-11ea-802c-9145fddcc8be.png)\r\n\r\n然后，我们在看看 temp 文件夹下的 index.html 中 body 最后的内容，是这样子的\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/86614427-90719400-bfe5-11ea-9205-bafcc6b59816.png)\r\n\r\n而，dist 文件夹下的 index.html 中 body 最后的内容，是这样子的\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/86614403-8485d200-bfe5-11ea-8b17-86fd20bfe131.png)\r\n\r\n**我们会得出一个结论，`useref` 这个插件，会自动帮我们把 以 `build` 开头，以 `endbuild` 结尾 中间的内容，合拼成一个文件**\r\n\r\nPS:这一段是精髓哈哈哈哈~\r\n\r\n我们再去看看 dist 目录下的 `vendor.js` 这个文件，我们可以发现，`useref` 会帮我们把 `node_module` 中使用到 js 文件都合拼在一起了。\r\n\r\n### 简化步骤\r\n\r\n好了，我们校验完 `useref` 这个任务后，我们在处理一下 dist 目录中的图片、字体、以及 ico 文件。我们可以看到 dist 目录下是少了 fonts 目录和 images 目录的。我们需要执行`useref`任务的时候，把图片、字体还有 ico 也一起处理下。我们可以多定义一个任务，叫做`build`,来帮我们一步到位。代码如下：\r\n\r\n```JavaScript\r\nconst build = series(\r\n  clean,\r\n  parallel(image, font, extra, series(compile, useref))\r\n);\r\n```\r\n\r\n这段代码的意思是，使用 `series` 定义一个组合任务，会按照顺序执行指定的任务。会先执行 `clean` 这个清除任务，再接着，执行一个由`parallel`组合串行任务，分别是`image`, `font`, `extra`，最后还有一个并行任务，先去执行`compile` 这个任务，接着再去执行`useref`。\r\n\r\n编写完后，我们需要把 `build` 这个任务导出，方便我们校验测试。接着，我们在命令行终端输入`yarn gulp build`,稍等一会，当任务执行完成后，我们看看 dist 文件夹，该有的文件都已经有啦！！！~\r\n\r\n### 编写 scripts 脚本\r\n\r\n最后一步啦！！！！\r\n\r\n加油 💪，把它看完啦！！！！\r\n\r\n我们来把 gulpfile.js 中的导出的任务整理一下，其实我们只需要用到这三个任务，分别是 `clean` 、 `develop` 、 `build`。我们把其他的任务都删除，只保留这三个任务就好啦。代码如下：\r\n\r\n```diff\r\nmodule.exports = {\r\n  clean,\r\n-  page,\r\n-  style,\r\n-  script,\r\n-  image,\r\n-  font,\r\n-  extra,\r\n-  serve,\r\n-  compile,\r\n  develop,\r\n-  useref,\r\n  build,\r\n};\r\n```\r\n\r\n你有没有发现啊，每次我们打包，或者启动项目的时候，总是要输入这样的命令，例如：`yarn gulp xxx`。我们可以在`package.json`中的`scripts`脚本中编写几个命令。代码如下:\r\n\r\n```diff\r\n+ "scripts": {\r\n+     "clean": "gulp clean",\r\n+     "serve": "gulp develop",\r\n+     "build": "gulp build"\r\n+ }\r\n```\r\n\r\n这样，我们就不需要在输入烦人的`yarn gulp xxx`了，我们在终端测试一下，分别输入 `yarn clean` 、`yarn serve` 、`yarn build`。都是能执行成功的，这样会不会高级一点，哈哈哈哈哈~\r\n\r\n至此，所有的内容都已经完结了，代码我已经提交到了 github 了，有需要的自己下载，如果有必要我会封装成一个 NPM 包。源码：https://github.com/Aisen60/gulp-page\r\n\r\n如果有问题，可以在底下进行评论，我会回复的。\r\n',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/12',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/12/labels{/name}',
    comments_url:
      'https://api.github.com/repos/Aisen60/blog/issues/12/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/12/events',
    html_url: 'https://github.com/Aisen60/blog/issues/12',
    id: 648351168,
    node_id: 'MDU6SXNzdWU2NDgzNTExNjg=',
    number: 12,
    title: '使用 grunt 进行项目的开发和打包',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-06-30T17:12:27Z',
    updated_at: '2020-07-05T07:10:00Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '# 使用 grunt 进行项目的开发和打包\r\n\r\n## 目标\r\n\r\n使用 grunt 提供一个在项目的开发过程中需要的服务器，要求实现热更新的功能，在项目开发完成后，编译压缩合拼文件，通过命令的方式帮助我们自动完成编译构建。\r\n\r\n## 说明\r\n\r\n文档中使用到的模板是这个：[aisen60-pages](https://github.com/Aisen60/aisen60-pages)\r\n\r\n文件夹结构\r\n\r\n```\r\n└── grunt-page ······································· 项目根目录\r\n   ├─ public ········································· 静态文件夹\r\n   │  └─ favicon.ico ·································\r\n   ├─ src ············································ 源文件夹\r\n   │  ├─ assets ······································ assets 文件夹\r\n   │  │  ├─ fonts ···································· 字体文件夹\r\n   │  │  │  └─ pages.eot ·····························\r\n   │  │  │  └─ pages.svg ·····························\r\n   │  │  │  └─ pages.ttf ·····························\r\n   │  │  │  └─ pages.woff ····························\r\n   │  │  ├─ images ··································· 图片文件夹\r\n   │  │  │  └─ brands.svg ····························\r\n   │  │  │  └─ logo.png ······························\r\n   │  │  ├─ scripts ·································· 脚本文件夹\r\n   │  │  │  └─ main.js ·······························\r\n   │  │  └─ styles ··································· 样式文件夹\r\n   │  │     ├─ _icons.scss ···························\r\n   │  │     ├─ _variables.scss ·······················\r\n   │  │     └─ main.scss ·····························\r\n   │  ├─ about.html ··································\r\n   │  └─ index.html ··································\r\n   ├─ .gitignore ····································· git忽略文件\r\n   ├─ README.md ······································ 项目说明文件\r\n   ├─ gruntfile.js ··································· grunt 任务文件\r\n   ├─ package.json ··································· package file\r\n   └─ yarn.lock ······································ yarn 锁定文件\r\n```\r\n\r\n# grunt 是什么？\r\n\r\ngrunt 是一个前端自动化构建工具，可以帮我们完成很多重复性的工作，例如压缩、编译、单元测试等等。grunt 本身不具备任何的打包编译功能，它只是一个任务工具，通过配置文件编写任务的形式，并且通过相关的插件帮助我们完成压缩、编译、单元测试等等之类的打包构建任务。\r\n\r\n## 安装 grunt\r\n\r\n克隆[模板](https://github.com/Aisen60/grunt-page)到本地，执行`yarn install`安装项目运行所需要的依赖。安装完依赖后，我们来安装 grunt。执行`yarn add grunt --dev`，安装完后，在项目根目录下新建一个`gruntfile.js`文件，这个 js 文件是 grunt 的入口文件和配置文件，用于定义一些 grunt 自动执行的任务，通过编写任务的方式完成来帮助我们完成构建任务。\r\n\r\n`gruntfile.js`需要导出一个函数，此函数接收一个 grunt 的形参，内部提供了创建任务时所需要用到的 api。\r\n\r\n```javascript\r\n// Grunt 的入口文件\r\n// 用于定义一些需要Grunt自动执行的任务\r\n// 需要导出一个函数\r\n// 此函数接收一个grunt的形参，内部提供一些创建任务时可以用到的API\r\nmodule.exports = (grunt) => {};\r\n```\r\n\r\n## 安装 load-grunt-tasks\r\n\r\n完成了 grunt 的安装之后，我们需要安装一个名字叫做`load-grunt-tasks`的包，这个包主要的作用是自动加载 grunt 插件中的任务。\r\n\r\n前面我们也说到了，grunt 它没有打包构建的能力，它只是一个任务工具，打包构建都是使用 grunt 相关的插件去完成的。\r\n\r\n输入`yarn add load-grunt-tasks --dev`安装这个插件。\r\n\r\n安装完成后，我们需要在 gruntfile.js 中引入这个插件，并且在调用执行它，让它自动加载 grunt 插件中的任务。\r\n\r\n```javascript\r\nconst loadGruntTasks = require("load-grunt-tasks");\r\nmodule.exports = (grunt) => {\r\n  loadGruntTasks(grunt);\r\n};\r\n```\r\n\r\n接下来，我们开始来编写构建任务。\r\n\r\n# 编写基础任务\r\n\r\n编写基础的任务的目标是，是为了后面搭建开发服务器和上线打包构建做准备。\r\n\r\n## 编写 clean 任务\r\n\r\n我们先编写一个清除目录的任务，这个任务会在后面的启动开发服务器任务和构建任务中使用到。\r\n\r\n`clean` 这个任务需要使用到一个名字叫做`grunt-contrib-clean`的插件。输入命令安装这个插件：`yarn add grunt-contrib-clean --dev`\r\n\r\n安装完成后，我们在`grunt.initConfig`多目标任务中配置一下 clean 这个任务的选项参数，我们需要给 clean 任务的定义多个目标，一个是 dist 目标，一个是 temp 目标，分别清除根目录下的 dist 和 temp 文件夹。\r\n\r\n```javascript\r\nconst loadGruntTasks = require("load-grunt-tasks");\r\nmodule.exports = (grunt) => {\r\n  loadGruntTasks(grunt);\r\n  grunt.initConfig({\r\n    clean: {\r\n      // main: ["dist", "temp"],\r\n      dist: "dist",\r\n      temp: "temp",\r\n    },\r\n  });\r\n};\r\n```\r\n\r\n设置完成后，为了验证 clean 任务是否成功，我们在根目录下新建 dist 和 temp 文件夹，新建成功后，在命令行终端输入 `yarn grunt clean` 执行 clean 任务，执行完 clean 这个任务后，根目录下的 dist 和 temp 文件夹会被清除。\r\n\r\n## 处理 scss，编写 sass 任务，将 scss 编译成可供浏览器执行的代码。\r\n\r\n接下来，我们在编写一个处理 scss 文件的任务，我们需要将 scss 编程成可供浏览器执行的 css 代码。需要安装两个包，分别是`grunt-sass`和`sass`。输入命令安装这两个插件：`yarn add grunt-sass sass --dev`。安装这两个包的时间会比较久，涉及到一些二进制的编码，可以换成 cnpm 安装，速度相对会快很多。\r\n\r\n安装完后，我们需要在 gruntfile.js 中引入 sass 这个包，并且在`grunt.initConfig`多目标任务中配置一下 sass 这个任务的选项参数，代码如下：\r\n\r\n```diff\r\n+ const sass = require("sass");\r\n+ sass: {\r\n+   options: {\r\n+     /**\r\n+       * style 参数说明\r\n+       * 编译后的css代码的格式有以下几种方式：\r\n+       * 嵌套输出方式 nested\r\n+       * 展开输出方式 expanded\r\n+       * 紧凑输出方式 compact\r\n+       * 压缩输出方式 compressed\r\n+       */\r\n+     style: "expanded",\r\n+     // implementation 使用什么标准来编译scss\r\n+     implementation: sass,\r\n+   },\r\n+   server: {\r\n+     opations: {\r\n+       // 是否开启 sourceMap,在开发环境建议开启sourceMap\r\n+       sourceMap: true,\r\n+     },\r\n+     //需要处理的文件，可支持多个文件\r\n+     files: {\r\n+       // 生产文件:目标文件\r\n+       "temp/assets/styles/main.css": "src/assets/styles/main.scss",\r\n+     }\r\n+   }\r\n+ }\r\n```\r\n\r\n编写完任务之后，我们在命令行终端输入 `yarn grunt sass` 来执行一下这个任务，任务执行完毕过后，我们可以看到根目录下多出了一个 `temp` 的文件夹，我们打开到`temp`下的`assets`文件夹下的`styles`文件夹，这里面有两个文件，分别是`main.css`和`main.css.map`,我们打开`main.css`，可以看到 scss 已经变成了 css 了。但是，怎么少了`_icons.scss`、`_variables.scss`这两个文件呢？这两个文件是没有被编译吗？其实，不是的，因为这两个文件都是以下划线开头的（\\_），在 scss 中标识是被引入的文件，所以这两个文件一同编译进了`main.css`文件中了。\r\n\r\n## 处理 js，编写 babel 任务，将 js、es6 等新特性编译可供浏览器执行的代码\r\n\r\n我们在编写 js 中，可能会使用到一些 es 的新特性，现在的浏览器还不能很好的支持 es 新特性，我们需要把 js 的代码编译 es5，这样就可供浏览器执行了。\r\n\r\n我们需要安装 `grunt-babel` 、`@babel/core` 、`@babel/preset-env`这 3 个插件，在命令行终端输入`yarn add grunt-babel @babel/core @babel/preset-env --dev`。\r\n\r\n安装完成后，需要在`grunt.initConfig`中编写一些配置。代码如下，包括了参数说明：\r\n\r\n```diff\r\n+ babel: {\r\n+   options: {\r\n+     //使用什么标准来编译js的代码\r\n+     presets: ["@babel/preset-env"],\r\n+   },\r\n+   server: {\r\n+     options: {\r\n+       //是否开启sourceMap，在开发环境建议开启\r\n+       sourceMap: true,\r\n+     },\r\n+     //需要处理的文件，可支持多个文件\r\n+     files: {\r\n+       // 生产文件:目标文件\r\n+       "temp/assets/scripts/main.js": "src/assets/scripts/main.js",\r\n+     }\r\n+   }\r\n+ }\r\n```\r\n\r\n编写完这个任务后，我们在终端输入命令执行这个任务`yarn grunt babel`。执行完后，我们打开 temp 目录下的 assets 目录下的 script 目录下的 main.js 文件，可以看到，原本在 src 文件夹下的 main.js 文件中的`const`关键词被替换成了`var`\r\n\r\n## 处理 html，编写 copy 任务\r\n\r\n接下来，我们需要处理 html，我们使用`grunt-contrib-copy`这个插件，将 src 目录下的 html 文件拷贝到 temp 文件夹下。在命令行终端输入：`yarn add grunt-contrib-copy --dev`来安装这个插件。安装完成过后啊，我们需要编写相关的任务，代码如下：\r\n\r\n```diff\r\n+ copy: {\r\n+   server: {\r\n+     files: [\r\n+       {\r\n+         expand: true,\r\n+         cwd: "src", //需要处理的文件（input）所在的目录。\r\n+         src: ["**/*.html"], ////表示需要处理的文件。如果采用数组形式，数组+ 的每一项就是一个文件名，可以使用通配符。\r\n+         dest: "temp", //表示处理后的文件名或所在目录。\r\n+       }\r\n+     ]\r\n+   }\r\n+ },\r\n```\r\n\r\n编写完任务后，我们执行一下这个任务：`yarn grunt copy:server` 。执行完后，我们在 temp 文件夹下可以看到，src 目录下的 index.html 和 about.html 已经拷贝到 temp 目录下了。\r\n\r\n## 处理图片、字体、以及其他类型文件\r\n\r\n最后一步，我们来编写图片、字体、以及其他类型文件的任务。需要使用到一个叫做`grunt-contirb-imagemin`的插件。在命令终端输入`yarn add grunt-contirb-imagemin --dev`来安装这个插件,yarn 安装这个插件可能会比较慢，可以使用 cnpm 安装。安装完后，我们开始编写任务，代码如下：\r\n\r\n```diff\r\n+ imagemin: {\r\n+   main: {\r\n+     options: {\r\n+       optimizationLevel: 1, //定义 PNG 图片优化水平\r\n+     },\r\n+     files: [\r\n+       {\r\n+         expand: true,\r\n+         cwd: "src/assets/images/", //原文件存放的文件夹\r\n+         src: ["**/*.{png,jpg,jpeg,gif,svg}"], //  images 目录下所有 png/jpg/jpeg/gif图片\r\n+         dest: "temp/assets/images", // 保存位置\r\n+       },\r\n+       {\r\n+         expand: true,\r\n+         cwd: "src/assets/fonts/", //原文件存放的文件夹\r\n+         src: ["**/*"], //  fonts 目录下所有 字体文件\r\n+         dest: "temp/assets/fonts", // 保存位置\r\n+       },\r\n+       {\r\n+         expand: true,\r\n+         cwd: "public/", // 原文件存放的文件夹\r\n+         src: ["**/*"], // public 目录下所有 字体文件\r\n+         dest: "temp/", // 保存位置\r\n+       }\r\n+     ]\r\n+   }\r\n+ }\r\n```\r\n\r\n编写完任务后，我们在命令行终端输入：`yarn grunt imagemin` 执行这个任务，执行完这个任务后，我们可以看到，temp 目录下已经有了相对应的图片文件、字体文件等，这是高保真的压缩，在不影响文件的情况下压缩文件的大小。\r\n\r\n至此，我们所有的基础任务已经编写完了。\r\n\r\n# 搭建开发服务器，并且实现热更新\r\n\r\n## 安装 grunt-browser-sync 插件\r\n\r\n开始之前，我们先执行一下`yarn clean`任务，删除 temp 文件夹和 dist 文件夹。\r\n\r\n我们需要启动一个服务帮我们把页面渲染出来，需要安装一个插件，叫做[grunt-browser-sync](http://www.browsersync.cn/docs/grunt/)。在命令终端输入`yarn add grunt-browser-sync --dev`。安装完成过后，我们需要在`grunt.initConfig`多目标任务中配置一下这个 browserSync 任务，代码如下：\r\n\r\n```diff\r\n+ browserSync: {\r\n+   dev: {\r\n+     options: {\r\n+       notify: false, //是否开启通知\r\n+       port: 6060, //启动的端口，如果不设置，默认是3000端口\r\n+       server: {\r\n+         baseDir: ["temp"], // 监听的目录\r\n+       }\r\n+     }\r\n+   }\r\n+ }\r\n```\r\n\r\n编写完任务后，在启动这个服务器之前啊，我们需要先执行以下 copy 任务，因为我们的定义服务器的监听的目录（baseDir）是 temp 文件夹，在浏览器终端依次输入 `yarn grunt copy 和`yarn grunt browserSync`，之后，系统会使用系统默认浏览器开打一个本地 6060 端口的页面，如下：\r\n\r\n<img alt="https://user-images.githubusercontent.com/19791710/86249864-6d5c7400-bbe2-11ea-89a6-efbc4cc6b5da.png" src="https://user-images.githubusercontent.com/19791710/86249864-6d5c7400-bbe2-11ea-89a6-efbc4cc6b5da.png">\r\n\r\n但是，你会发现页面没有任何的样式，我们打开到 temp 目录下的 index.html 文件，看到引入样式文件，一个是 node_modules 包的 bootstrap.css，一个是 assets/styles 下的 main.css。main.css 在 temp 下都没有，我们第一步在解决 main.css 这个问题。那这个问题很简单，我们可以在任务启动的时候，执行一下我们在基础任务中的编写的 sass 这个任务。\r\n\r\n那要咋做呢？我们可以在编写一个 develop 任务，这个任务就是 sass 任务和 browserSync 任务组合，我们可以使用 grunt 提供的一个叫做`registerTask`的 api 定义一个任务。这个 api 有 3 个参数，第一个是任务的名称，第二个任务是任务的说明，第三个参数是执行体。如果第二个参数不是字符串，是个数组或者函数的话，那么会被视为任务的执行体。\r\n\r\n代码如下：\r\n\r\n```diff\r\n+ grunt.registerTask("develop", "启动web服务器", [\r\n+   "clean",\r\n+   "copy:server",\r\n+   "sass:server",\r\n+   "babel:server",\r\n+   "browserSync",\r\n+ ]);\r\n```\r\n\r\n我们需要在启动这个服务器时先清除 temp 这个目录，然后执行 copy 这个多任务中的 server 任务，将 src 下的所有 html 文件拷贝到 temp 目录下，再接着去处理 sass 的编译，最后启动服务器。\r\n\r\n我们执行 develop 这个任务，他会自动启动一个服务器，我们看到 temp 文件夹下已经生成了 main.css 文件了，我们再次打开页面来看看。你会发现还是一样啊，没有什么变化，我们打开 F12，切换到 Network 下的 css，发现 main.css 已经加载进来了。\r\n\r\n现在剩下的要解决的是，node_module 包的引用问题。我们要使用到 browserSync 这个插件的另外一个选项，叫做 routes，前置路由的配置，把 html 中使用到的 node_module 映射到根目录下的 node_module。\r\n\r\n代码如下：\r\n\r\n```diff\r\nbrowserSync: {\r\n  dev: {\r\n    options: {\r\n      notify: false, //是否开启通知\r\n      port: 6060, //启动的端口，如果不设置，默认是3000端口\r\n      server: {\r\n        baseDir: ["temp"], // 监听的目录\r\n+       routes: {\r\n+         // 前置路由，设置了路由后，会去找项目目录中指定的文件夹\r\n+         "/node_modules": "node_modules",\r\n+       },\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n然后，我们重新执行以下 develop 任务。打开浏览器，你会发现页面的样式已经是正常了的，打开到控制台我们来看，bootstrap.css 也被加载进来了。\r\n\r\n我们在检查一下其他页面的样式或者图片是否显示正确，我们打开到 about 页面，发现图片和网站的 ico 没有加载进来，因为 temp 文件夹下根本就没有图片。我们可以把图片也打包进来当执行了 develop 的时候。但是，没有太大的必要，因为在开发阶段，不需要把什么文件都打包进来，所以我们可以通过监听多个目录来实现这个功能。修改一下 baseDir 的监听目录就可以了\r\n\r\n```diff\r\nbrowserSync: {\r\n  dev: {\r\n    options: {\r\n      notify: false, //是否开启通知\r\n      port: 6060, //启动的端口，如果不设置，默认是3000端口\r\n      server: {\r\n-       baseDir: ["temp"], // 监听的目录\r\n+       baseDir: ["temp","src","public"], // 监听的目录\r\n        routes: {\r\n         // 前置路由，设置了路由后，会去找项目目录中指定的文件夹\r\n         "/node_modules": "node_modules",\r\n        },\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n这样，我们的一个完整的开发服务器就配置完了，接下来要实现热更新的功能。\r\n\r\n## 实现热更新\r\n\r\n要实现热更新的功能，需要安装一个插件，叫做`grunt-contrib-watch`，我们在终端输入`yarn add grunt-contrib-watch --dev`来安装一下这个插件，实现热更新要和 browser-sync 插件一起使用。\r\n\r\n第一步，我们需要在 browserSync 任务中启动`watchTask`是否启动监听\r\n\r\n```diff\r\nbrowserSync: {\r\n  dev: {\r\n    options: {\r\n+     watchTask: true,\r\n      notify: false, //是否开启通知\r\n      port: 6060, //启动的端口，如果不设置，默认是3000端口\r\n      server: {\r\n        baseDir: ["temp","src","public"], // 监听的目录\r\n        routes: {\r\n         // 前置路由，设置了路由后，会去找项目目录中指定的文件夹\r\n         "/node_modules": "node_modules",\r\n        },\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n第二步，我们需要在`grunt.initConfig`中编写一些 watch 监听任务和添加几个 clean 任务\r\n\r\n```diff\r\nclean: {\r\n  dist: "dist",\r\n  temp: "temp",\r\n+  html: "temp/*.html",\r\n+  css: "temp/assets/styles/*",\r\n+  js: "temp/assets/scripts/*",\r\n+  images: "temp/assets/images",\r\n+  fonts: "temp/assets/fonts",\r\n+  ico: "temp/favicon.ico",\r\n}\r\n\r\n+ watch: {\r\n+   html: {\r\n+     files: ["src/*.html", "src/**/*.html"],\r\n+     tasks: ["clean:html", "copy:server"],\r\n+   },\r\n+   css: {\r\n+     files: ["src/assets/styles/*"],\r\n+     tasks: ["clean:css", "sass:server"],\r\n+   },\r\n+   js: {\r\n+     files: ["src/assets/scripts/*"],\r\n+     tasks: ["clean:js", "babel:server"],\r\n+   },\r\n+   otherFile: {\r\n+     files: ["src/assets/images/*", "src/assets/fonts/*", "public/*"],\r\n+     tasks: ["clean:images", "clean:fonts", "imagemin:temp"],\r\n+   },\r\n+ },\r\n```\r\n\r\n**watch 中，我们添加了 html、css、js、otherFile 这几个任务，意思是，监听指定的目录文件，当文件发生改变时，触发指定的任务。并且修改了 develop 这个任务，添加了 watch 任务，这个 watch 任务一定要放到最后在执行。**\r\n\r\n编写完任务后，我们在命令行终端重新执启动一下服务器，`yarn grunt develop`。\r\n\r\n![https://user-images.githubusercontent.com/19791710/86508614-01615200-be14-11ea-84c6-49cb797b1c29.png](https://user-images.githubusercontent.com/19791710/86508614-01615200-be14-11ea-84c6-49cb797b1c29.png)\r\n\r\n当服务器启动完后，我们修改一下 header 的名称，修改完后，切换到浏览器，我们无需刷新，就可以看到已经修改了。\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/86508656-65841600-be14-11ea-9f8d-0b27d3468665.png)\r\n\r\n# 上线时的打包编译\r\n\r\n最后，我们来编写项目上线时要做的文件合拼、文件压缩等。\r\n\r\n## 编写多一个 copy 任务，将 temp 下的所有内容拷贝到 dist\r\n\r\n```diff\r\ncopy: {\r\n  server: {\r\n    files: [\r\n      {\r\n        expand: true,\r\n        cwd: "src", //需要处理的文件（input）所在的目录。\r\n        src: ["**/*.html"], ////表示需要处理的文件。如果采用数组形式，数组的每一项就是一个文件名，可以使用通配符。\r\n        dest: "temp", //表示处理后的文件名或所在目录。\r\n      },\r\n    ],\r\n  },\r\n+  build: {\r\n+    files: [\r\n+      {\r\n+        expand: true,\r\n+        cwd: "temp",\r\n+        src: ["**/*"],\r\n+        dest: "dist",\r\n+      },\r\n+    ],\r\n+  },\r\n},\r\n```\r\n\r\n编写完 copy 任务后，我们执行一下，`yarn grunt copy:build`任务。执行完后，dist 文件夹是已经存在了，并且把 temp 文件夹下的内容都已经拷贝过来了。\r\n\r\n## 合拼文件\r\n\r\n合拼文件所需要用到的有两个插件，一个是`grunt-useref`，一个是`grunt-contrib-concat`。我们先来安装一下这两个插件。`yarn add grunt-useref grunt-contrib-concat --dev`\r\n\r\ngrunt-useref 这个插件的作用呢，主要是把图一的编译成图二的，如下图\r\n\r\n图一：\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/86509494-ee05b500-be1a-11ea-9bbb-d0910181bbeb.png)\r\n\r\n图二：\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/86509517-142b5500-be1b-11ea-9fbd-7556cdc533ad.png)\r\n\r\n而 grunt-contrib-concat 是将 jquery、popper、bootstrap 这三个 js 文件合拼成一个 vendor.js 文件\r\n\r\n我们来编写以下这两个任务：\r\n\r\n```diff\r\n+ useref: {\r\n+   html: "dist/**/*.html",\r\n+   temp: "dist",\r\n+ },\r\n\r\n\r\n+ concat: {\r\n+   options: {\r\n+     separator: ";",\r\n+   },\r\n+   js: {\r\n+     src: [\r\n+       "node_modules/jquery/dist/jquery.js",\r\n+       "node_modules/popper.js/dist/umd/popper.js",\r\n+       "node_modules/bootstrap/dist/js/bootstrap.js",\r\n+     ],\r\n+     dest: "dist/assets/scripts/vendor.js",\r\n+   },\r\n+   css: {\r\n+     src: ["node_modules/bootstrap/dist/css/bootstrap.css"],\r\n+     dest: "dist/assets/styles/vendor.css",\r\n+   },\r\n+ },\r\n```\r\n\r\n编写完任务后，我们一个一个来执行，先执行 useref 这个任务，执行完后，打开 dist 文件夹下的 index.html 文件，我们能发现，已经从图一变成图二的了。\r\n\r\n在执行一下 concat 这个任务，执行后，你会发现 dist 文件夹下多了 vendor.js 和 vendor.css 文件，我们打开看看，vendor.js 文件已经是 jquery、popper、bootstrap 这 3 个库的合拼了，vendor.css 已经把 bootstrap 合拼进来了。\r\n\r\n## 压缩 html 文件\r\n\r\n压缩 html 文件需要用到的插件是`grunt-contrib-htmlmin`，我们执行命令输入`yarn add grunt-contrib-htmlmin --dev`。编写压缩 html 任务\r\n\r\n```diff\r\n+ htmlmin: {\r\n+   build: {\r\n+     options: {\r\n+       removeComments: true, //移除注释\r\n+       collapseWhitespace: true,//折叠文档，去除多余空格\r\n+       conservativeCollapse: true,//设置成一行\r\n+       minifyJS: true,//缩小脚本元素和事件属性中的JavaScript\r\n+       minifyCSS: true,//缩小样式元素和样式属性中的CSS\r\n+     },\r\n+     files: [\r\n+       {\r\n+         expand: true,\r\n+         cwd: "dist", //需要处理的文件（input）所在的目录。\r\n+         src: ["**/*.html"], //表示需要处理的文件。如果采用数组形式，数组的每一项+ 就是一个文件名，可以使用通配符。\r\n+         dest: "dist/", //表示处理后的文件名或所在目录。\r\n+       },\r\n+     ],\r\n+   },\r\n+ },\r\n```\r\n\r\n编写完任务后，我们来执行当前这个任务，`yarn grunt htmlmin`，执行完后，我们打开 dist 文件夹下的 index.html 文件和 about.html 文件，我们发现已经被压缩成了一行。\r\n\r\n那接下来的工作就是压缩 css 和 js 了。\r\n\r\n## 压缩 css\r\n\r\n压缩 css 要使用到一个插件，叫做`grunt-css-clean` 我们来安装一下，`yarn add grunt-css-clean --dev`\r\n\r\n安装完后，我们来编写任务：\r\n\r\n```diff\r\n+ css_clean: {\r\n+   build: {\r\n+     files: [\r\n+       {\r\n+         expand: true,\r\n+         cwd: "dist",\r\n+         src: ["assets/styles/**/*.css"],\r\n+         dest: "dist",\r\n+       },\r\n+     ],\r\n+   },\r\n+ },\r\n```\r\n\r\n编写完后，我们执行这个任务，`yarn grunt css_clean`，执行完过后，我们重新看一下 dist 文件夹下的 css 文件，我们打开，发现已经编译压缩好了。\r\n\r\n## 压缩 js\r\n\r\n压缩 js 要使用到一个插件，叫做`grunt-contrib-uglify` 我们来安装一下，`yarn add grunt-contrib-uglify --dev`\r\n\r\n安装完后，我们来编写任务：\r\n\r\n```diff\r\n+ // 压缩js\r\n+ uglify: {\r\n+   options: {\r\n+     mangle: true, //混淆变量名\r\n+     comments: "false", //false（删除全部注释），some（保留@preserve @license @cc_on等注释）\r\n+   },\r\n+   build: {\r\n+     files: [\r\n+       {\r\n+         expand: true,\r\n+         cwd: "temp", //js目录下\r\n+         src: ["assets/scripts/*.js"], //所有js文件\r\n+         dest: "dist/assets/scripts", //输出到此目录下\r\n+       },\r\n+     ],\r\n+   },\r\n+ },\r\n```\r\n\r\n编写完成后,我们执行一下 uglify 这个命令，`yarn grunt uglify` 执行完后，我们看到 dist 文件夹下的 js 文件都已经是压缩好了的。\r\n\r\n那至此，我们需要把上面几个的任务组合成一个任务，来完成最后的工作。\r\n\r\n## 整合任务\r\n\r\n```diff\r\n+ grunt.registerTask("complie", ["copy:server", "sass:server", "babel:server"]);\r\n+\r\n+ grunt.registerTask("develop", "启动web服务器", [\r\n+   "clean",\r\n+   "complie",\r\n+   "browserSync",\r\n+   "watch",\r\n+ ]);\r\n+\r\n+ grunt.registerTask("build", [\r\n+   "clean",\r\n+   "complie",\r\n+   "imagemin",\r\n+   "copy",\r\n+   "concat",\r\n+   "useref",\r\n+   "htmlmin",\r\n+   "css_clean",\r\n+   "uglify",\r\n+ ]);\r\n```\r\n\r\npackage.json 文件添加下面 script 命令\r\n\r\n```json\r\n"scripts": {\r\n  "clean": "grunt clean",\r\n  "serve": "grunt develop",\r\n  "build": "grunt build"\r\n},\r\n```\r\n\r\n',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/11',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/11/labels{/name}',
    comments_url:
      'https://api.github.com/repos/Aisen60/blog/issues/11/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/11/events',
    html_url: 'https://github.com/Aisen60/blog/issues/11',
    id: 633429499,
    node_id: 'MDU6SXNzdWU2MzM0Mjk0OTk=',
    number: 11,
    title: '脚手架工具 学习笔记',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-06-07T13:46:08Z',
    updated_at: '2020-06-11T05:54:45Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '# 脚手架是什么\r\n\r\n可以理解为自动创建项目基础结构、提供项目规范和约定的工具。看似很普通的需求，背后却包含了一定的哲学。脚手架除了创建文件，还提供了一些约定和规范。当我们去开发相同类型项目时，都会有一些相同的约定，比如说：\r\n\r\n- 相同的组织结构\r\n- 相同的开发范式\r\n- 相同的模块依赖\r\n- 相同的工具配置\r\n- 相同的基础代码\r\n\r\n这样的话，当我们要搭建新项目的时候需要做大量的重复性工作，脚手架工具就是用来解决这样的问题的。我们可以根据脚手架去搭建一个特定的骨架，接着后面的就可以基于这个骨架上进行开发工作。\r\n\r\n# 常用的脚手架工具\r\n\r\n目前市面上有很多成熟的脚手架工具，但是很多脚手架都是为了特定的项目类型服务的，比如说：\r\n\r\n- `React` 项目 -> `create-react-app `\r\n- `Vue.js` 项目 -> `vue-cli`\r\n- `Angular`项目 -> `angular-cli`\r\n\r\n这些工具的实现都是大同小异，无外乎就是根据信息创建对应的项目基础结构，不过一般只适用于它们自身的服务。\r\n\r\n还有一类呢就是以`Yeoman`工具为代表的通用型项目脚手架工具，它们可以根据一套模板生成一个对应的项目结构，这种项目类型的脚手架一般都很灵活也很容易拓展。\r\n\r\n除了上面这种创建项目时会用到的脚手架工具外，还有一种用来在项目开发过程中创建特定类型的文件，比如说有`Plop`。\r\n\r\n在简单了解了这些工具的介绍后，我们拿`yeoman`和`Plop`做深入的探究。\r\n\r\n# Yeoman 简介\r\n\r\nYeoman是一款通用型的脚手架工具，它可以创建任何类型的应用程序，它更像是一个脚手架运行平台，我们可以通过不同的`generator`创建任何类型的项目。它是基于`nodejs`开发的。\r\n\r\n## `generator` 是什么？\r\n\r\n`generator` 翻译成中文是**生成器**的意思，可以理解成就是它是一个`Yeoman`的`api`。`Yeoman`就是通过`generotor`来生成指定的项目结构。~~换句话说`generotor`就是`Yeoman`脚手架生成器~~\r\n\r\n# Yeoman 基础使用\r\n\r\n## 安装\r\n\r\n使用`yarn`全局安装`Yeoman`：\r\n\r\n```\r\nyarn global add yo\r\n```\r\n\r\n安装完成后，还要安装相对应类型的`generator`，因为`Yeoman`要和`generator`一起搭配使用的，要找到相对应类型的`generator`。这里我们需要生成一个`node-module`的项目，就可以使用`generator-node`的模块。所以我们这里要安装`generator-node`。\r\n\r\n```\r\nyarn global add generator-node\r\n```\r\n\r\n## 运行\r\n\r\n当我们安装完`Yeoman`和相对应类型的`generator`后，我们可以通过下面的命令来生成一个全新的`node-module`：\r\n\r\n```\r\nyarn global add generator-node\r\n```\r\n\r\n我们在设备中一个指定的目录下创建一个名为`my-module`的文件夹，并且使用命令行打开当前创建的目录。然后我们输入:\r\n\r\n```\r\nyo node // node 就是相对应类型的generator的名称\r\n```\r\n\r\n执行完后，会让我们填写一些信息，如下：\r\n\r\n```\r\nmy-module yo node\r\n? Module Name my-module // 模块的名字。\r\n(node:13804) [DEP0066] DeprecationWarning: OutgoingMessage.prototype._headers is deprecated\r\n// 这里提示，你的模块在npm上已经存在了，是否需要更改其他的名字。因为这里只是做演示，我这里选择No\r\n? The name above already exists on npm, choose another? No \r\n// 模块的描述\r\n? Description awesome node module \r\n// 项目地址首页\r\n? Project homepage url https://github.com/Aisen60 \r\n// 作者名称\r\n? Author\'s Name Aisen60 \r\n// 作者邮箱\r\n? Author\'s Email caixusheng60@gmail.com \r\n// 作者主页\r\n? Author\'s Homepage https://aisen60.now.sh \r\n// 模块关键字，多个使用逗号隔开\r\n? Package keywords (comma to split) module,node \r\n// 这里会问你，是否发送代码覆盖率的报告到某个平台上。后面的课程会讲到持续继承和代码质量保证的一些工具，这里选择No\r\n? Send coverage reports to coveralls No \r\n//兼容的node版本，默认兼容所有，我这里没有输入，就是默认的\r\n? Enter Node versions (comma separated) \r\n// github的用户名\r\n? GitHub username or organization Aisen60\r\n// 选择项目的license，选择MIT\r\n? Which license do you want to use? MIT\r\n   create package.json\r\n    force .yo-rc.json\r\n    force ../../../../../.yo-rc-global.json\r\n   create README.md\r\n   create .editorconfig\r\n   create .gitattributes\r\n   create .gitignore\r\n   create .travis.yml\r\n   create .eslintignore\r\n   create lib/index.js\r\n   create LICENSE\r\n   create lib/__tests__/myModule.test.js\r\n   \r\nI\'m all done. Running npm install for you to install the required dependencies. If this fails, try running the command yourself.   \r\n```\r\n\r\n输入完全部信息后，会在当前目录下自动创建一些基础文件和一些配置文件，并且会在当前目录下自动运行`npm install`，会自动帮助我们安装依赖。\r\n\r\n那整个脚手架的流程就结束了，脚手架的目的就是为了让我们得到一个这样的基础结构，需要依赖相对应类型的`generator`。\r\n\r\n## 总结\r\n\r\n- 在使用`Yeoman`的时候需要在全局安装一个名为`yo`的工具\r\n\r\n  ```\r\n  npm install yo --global # or yarn global add yo\r\n  ```\r\n\r\n- 有了`yo`这个工具外，我们还需要安装特定类型的`generator`。因为不同的`generator`用来生成不同的项目。当前演示的是一个生成node项目的一个叫做`generator-node`的模块。\r\n\r\n  ```\r\n  npm install generator-node --global # or yarn global add generator-node\r\n  ```\r\n\r\n- 通过`yo`运行`generator`来执行`generator-node`，生成指定的项目结构\r\n\r\n  ```\r\n  npm install generator-node --global # or yarn global add generator-node\r\n  ```\r\n\r\n# Yeoman 使用步骤总结\r\n\r\n1. 明确你的需求；\r\n2. 找到合适的`generator`；\r\n3. 全局范围安装找到的`generator`；\r\n4. 通过`yo`运行对应的`generator`；\r\n5. 通过命令行交互填写选项；\r\n6. 生成你需要的项目结构；\r\n\r\n# 基于Yeoman搭建自己的脚手架\r\n\r\n市面上的`generator`不一定符合自身项目的需求，我们可以通过创建自己的`generator`来自定义生成项目结构，比如说，在`vue`项目中，虽然官方提供了`vue-cli`，但是，我们在项目中用到的`axios`、`ElementUI`等常用的库以及一些通用的方法和业务还是会重复用到的，这个时候我们可以把公共的部分放到脚手架去生成。\r\n\r\n## 创建`generator`模块\r\n\r\n创建`generator`其实就是创建一个`npm`模块，但是`generator`有特定的结构，如下：\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/83966821-2f27a980-a8ef-11ea-887a-c0f45b3971d5.png)\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/83966851-4ebed200-a8ef-11ea-82bb-94b8e7bd3d26.png)\r\n\r\n还有一个和`npm`不同的是,`Yeoman`的名称必须是`generator-<name>`这样的形式开头。\r\n\r\n1. 接下来，我们在硬盘中创建一个目录，名字为`generator-sample `。\r\n\r\n2. 进入该目录，通过`yarn init` 初始化一个`package.json`\r\n\r\n   ```\r\n   yarn init\r\n   ```\r\n\r\n3. 使用编辑器打开`generator-sample `项目\r\n\r\n4. 安装`yeoman-generator`，这个模块提供了生成器的一个基类，这个基类提供了一些工具和函数，让我们在创建生成器的时候更加便捷。\r\n\r\n   ```\r\n   yarn add yeoman-generator\r\n   ```\r\n\r\n5. 在项目中创建一个`generators`文件夹，并且在`generator`文件夹下创建一个`index.js`的入口文件\r\n\r\n6. 并且在`index.js`中写入下面👇的代码：\r\n\r\n   ```javascript\r\n   // 此文件作为 Generator 的核心入口\r\n   // 需要导出一个继承自 Yeoman Generator 的类型\r\n   // Yeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法\r\n   // 我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，例如文件写入\r\n   \r\n   const Generator = require("yeoman-generator");\r\n   \r\n   module.exports = class extends Generator {\r\n     writing() {\r\n       // Yeoman 自动在生成文件阶段调用此方法\r\n       // 我们这里尝试往项目目录中写入文件\r\n       this.fs.write(this.destinationPath("temp.txt"), Math.random().toString());\r\n     }\r\n   };\r\n   \r\n   ```\r\n\r\n   这段代码的意思是，引入了一个`yeoman-generator`的模块，并且导出时继承了这个`yeoman-generator`模块，在导出的对象中调用了一个`yeoman`的生命周期`writing`函数，在这个函数里面写了一个名为`temp`的txt文件，这个txt文件的内容是一个随机数，并且把这个生成的`temp.txt`文件放到当前目录。\r\n\r\n   `yeoman`中常用的生命周期函数有这几个，分别是：\r\n\r\n   - initializing - 初始化函数\r\n   - prompting - 接收用户输入阶段\r\n   - default - 执行自定义函数\r\n   - writing - 生成项目目录结构阶段\r\n   - install - 安装依赖阶段\r\n\r\n7. 通过`yarn.link`或者`npm.link`的方式，让它成为一个全局的模块包。\r\n\r\n   ```\r\n   yarn.link\r\n   ```\r\n\r\n   可以通过`yarn.unlink 包名`或者`npm.unlink 包名`的方式，取消全局引用。\r\n\r\n   设置成功后会出现以下提示：\r\n\r\n   ![image](https://user-images.githubusercontent.com/19791710/83969358-28566200-a902-11ea-943d-3cfacaa23cc3.png)\r\n\r\n8. 接着，我们在硬盘中在创建一个名为`my-project`的项目文件夹。通过命令行打开这个文件夹，输入`yo sample`\r\n\r\n   ```\r\n   yo sample\r\n   ```\r\n\r\n   这个时候，控制台会输出以下信息，我们看到了这个信息就表示脚手架已经自动生成了一个`temp.txt`的文件\r\n\r\n   <img width="233" alt="https://user-images.githubusercontent.com/19791710/83969485-e679eb80-a902-11ea-892c-fd26a6637914.png" src="https://user-images.githubusercontent.com/19791710/83969485-e679eb80-a902-11ea-892c-fd26a6637914.png">\r\n\r\n   \r\n\r\n9. 打开`temp.txt`这个文件，我们可以看到一个随机数。\r\n\r\n   <img  alt="屏幕快照 2020-06-07 21 09 51" src="https://user-images.githubusercontent.com/19791710/83969558-41134780-a903-11ea-95ab-d46ffd740668.png">\r\n\r\n   那这就是一个`Yeoman`生成器最基本的开发过程。\r\n\r\n## 根据模板创建文件\r\n\r\n很多时候，我们需要创建的文件有很多，而且文件内容也相对会比较复杂，那这种情况下，我们就可以用模板的方式去创建文件，这样的话，可以更加便捷。\r\n\r\n回到`generator-sample `项目中\r\n\r\n1. 在app文件夹下，创建一个名为`templates`的文件夹，下面创建一个`bar.html`和`foo.txt`，并且输入以下代码：\r\n\r\n   `bar.html`：\r\n\r\n   ```html\r\n   <!DOCTYPE html>\r\n   <html lang="en">\r\n   \r\n   <head>\r\n       <meta charset="UTF-8">\r\n       <meta name="viewport" content="width=device-width, initial-scale=1.0">\r\n       <meta http-equiv="X-UA-Compatible" content="ie=edge">\r\n       <title><%= name %></title>\r\n   </head>\r\n   \r\n   <body>\r\n       <h1><%= name %></h1>\r\n   </body>\r\n   \r\n   </html>\r\n   ```\r\n\r\n   `foo.txt`:\r\n\r\n   ```\r\n   这是一个模板文件\r\n   内部可以使用 EJS 模板标记输出数据\r\n   例如：<%= title %>\r\n   \r\n   其他的 EJS 语法也支持\r\n   \r\n   <% if (success) { %>\r\n   哈哈哈\r\n   <% }%>\r\n   ```\r\n\r\n   模板中的语法完全是遵循`EJS`的模板引擎的语法\r\n\r\n2. 有了模板之后，就不需要借助`fs.write`去写入文件。修改`index.js`文件：\r\n\r\n   ```javascript\r\n   const Generator = require("yeoman-generator");\r\n   \r\n   module.exports = class extends Generator {\r\n     writing() {\r\n       // Yeoman 自动在生成文件阶段调用此方法\r\n       // 我们这里尝试往项目目录中写入文件\r\n       // this.fs.write(this.destinationPath("temp.txt"), Math.random().toString());\r\n   \r\n       // -------------------------------------------------------\r\n   \r\n       // 通过模板方式写入到目标目录\r\n   \r\n       // 模板文件路径\r\n       const tmpl = this.templatePath("foo.txt");\r\n   \r\n       // 输出目标路径\r\n       const output = this.destinationPath("foo.txt");\r\n   \r\n       // 模板数据上下文\r\n       const context = { title: "Hello zce~", success: false };\r\n   \r\n       this.fs.copyTpl(tmpl, output, context);\r\n     }\r\n   };\r\n   ```\r\n\r\n   这段代码的意思是，定义了三个变量，第一个变量用来存放模板的文件路径，第二个变量用来存放输出目标的路径，第三个变量用来存放模板的数据，最后使用`fs.copyTpl`这个方法，它会自动把模板文件映射到生成的目标文件上。\r\n\r\n3. 回到`my-project`项目中，我们重新输入`yo sample`。\r\n\r\n   ```\r\n   yo sample\r\n   ```\r\n\r\n   这个时候，控制台会输出以下信息，我们看到了这个信息就表示脚手架已经自动生成了一个`foo.txt`的文件\r\n   ![image](https://user-images.githubusercontent.com/19791710/83970266-61dd9c00-a907-11ea-95d9-f835e187238c.png)\r\n\r\n   \r\n\r\n4. 打开`foo.txt`这个文件，我们可以看到以下内容：\r\n\r\n   <img width="721" alt="屏幕快照 2020-06-07 21 41 44" src="https://user-images.githubusercontent.com/19791710/83970321-b7b24400-a907-11ea-9a9a-c21eee7c7b51.png"> \r\n\r\n**相对于手动创建每一个文件，模板的方式大大提高了效率，特别是文件比较多比较复杂的情况下**\r\n\r\n## 接收用户输入\r\n\r\n对于模板当中的一些动态的数据，例如项目名称、项目的简介，版本号等，这样的数据一般通过命令行的方式去询问使用者从而得到，在`generator`中想要发起一个命令行交互询问，我们可以通过实现`generator`类型当中的`prompting`方法发起对用户的询问。\r\n\r\n```javascript\r\nconst Generator = require(\'yeoman-generator\')\r\n\r\nmodule.exports = class extends Generator {\r\n  prompting () {\r\n    // Yeoman 在询问用户环节会自动调用此方法\r\n    // 在此方法中可以调用父类的 prompt() 方法发出对用户的命令行询问\r\n    return this.prompt([\r\n      {\r\n        type: \'input\',\r\n        name: \'name\',\r\n        message: \'Your project name\',\r\n        default: this.appname // appname 为项目生成目录名称\r\n      }\r\n    ])\r\n    .then(answers => {\r\n      // answers => { name: \'user input value\' }\r\n      this.answers = answers\r\n    })\r\n  }\r\n    writing () {\r\n      \r\n    // 模板文件路径\r\n    const tmpl = this.templatePath(\'bar.html\')\r\n    // 输出目标路径\r\n    const output = this.destinationPath(\'bar.html\')\r\n    // 模板数据上下文\r\n    const context = this.answers\r\n\r\n    this.fs.copyTpl(tmpl, output, context)\r\n  }\r\n} \r\n```\r\n\r\n在这个`prompting`方法中，调用父类的提供的`prompt() `方法发出对用户的命令行询问。这个方法接收一个数组，并且返回一个`promise`，所以需要对这个方法进行`return`，这样的话`yeoman`在工作的时候会有更好的异步流程控制。数组是一个对象数组，每一个对象就是每一个问题，对象中包含了一些特定的属性，具体查看[官方api](https://yowebapp.github.io/authoring/user-interactions.html)，这里只罗列常用的属性：\r\n\r\n- type 交互的方式\r\n- name 最终得到结果的一个键\r\n- message 命令行中给用户的一个提示\r\n- default 默认值，提供一个默认值将阻止用户返回任何空的答案\r\n\r\n在这个`promise`执行过后，我们可以`then`方法中得到一个`answers`，这个`answers`就是用户输入完成后的结果，它会以一个对象的形式返回，对象中的键，就是我们在数组中定义的`name`属性，值就是用户输入的内容。我们将这个返回的对象挂载到`this`对象中，以便我们在上下文中使用它。有了`answers`这个数据后，我们可以在`writing`的方法中，作为模板数据。\r\n\r\n返回到控制台中，我们输入`yo sample`,可以看到有命令行中提示我们一个问题，`Your project name `\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/84052630-6a0b0980-a9e3-11ea-95d8-02ee24cbfda3.png)\r\n\r\n可以根据自己的需要去输入，输入完成后，会把我们输入的作为结果输出到我们自定义的模板文件中。\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/84052833-ae96a500-a9e3-11ea-8f17-fe2cadd69610.png)\r\n\r\n## Vue Generator 案例\r\n\r\n我们重头开始，来制作一个`Vue Generator`脚手架，这个脚手架中是把一些我们常用的通用的一些业务和代码封装了在一起，这样的话，我们就可以省去很多的时间，可以提高效率。\r\n\r\n1. 新建一个`generator-aisen60-vue`的文件夹\r\n\r\n2. 进入到`generator-aisen60-vue`目录下，初始化一个`package.json`文件\r\n\r\n   ```\r\n   yarn init # or npm init\r\n   ```\r\n\r\n3. 安装`yeoman-generator`依赖\r\n\r\n   ```\r\n   yarn add yeoman-generator # or npm install yeoman-generator\r\n   ```\r\n\r\n4. 在`generator-aisen60-vue`根目录下，新建一个`generators`文件夹，并且在`generators`文件夹下新建一个`app`文件夹，然后在`app`文件夹下新建一个`index.js`作为我们当前`generators`的主入口。\r\n\r\n5. 在`app`文件夹下，新建一个`templates`文件夹，把[模板文件](https://github.com/Aisen60/vue-templates)复制到`templates`，作为模板文件。\r\n\r\n6. 在`index.js`文件中写入以下代码：\r\n\r\n   ```javascript\r\n   const Generator = require("yeoman-generator");\r\n   \r\n   module.exports = class extends Generator {\r\n     //使用prompting生命周期方法，在命令行发起对用户的询问。\r\n     prompting() {\r\n       // 这个方法接收一个数组作为参数，并且返回一个promise对象。所以需要对这个方法进行 return，这样的话 yeoman 在工作的时候会有更好的异步流程控制。\r\n       // 数组中的每一项是一个对象，每一个对象代表着要向用户循环的问题。\r\n       return this.prompt([\r\n         {\r\n           type: "input",\r\n           name: "name",\r\n           message: "your project name",\r\n           default: this.appname,\r\n         },\r\n       ]).then((answers) => {\r\n         this.answers = answers;\r\n       });\r\n     }\r\n     writing() {\r\n       // 把每一个文件都通过模板转换到目标路径\r\n       const templates = [\r\n         ".browserslistrc",\r\n         ".editorconfig",\r\n         ".env.development",\r\n         ".env.production",\r\n         ".eslintrc.js",\r\n         ".gitignore",\r\n         "babel.config.js",\r\n         "package.json",\r\n         "postcss.config.js",\r\n         "README.md",\r\n         "public/favicon.ico",\r\n         "public/index.html",\r\n         "src/App.vue",\r\n         "src/main.js",\r\n         "src/router.js",\r\n         "src/assets/logo.png",\r\n         "src/components/HelloWorld.vue",\r\n         "src/store/actions.js",\r\n         "src/store/getters.js",\r\n         "src/store/index.js",\r\n         "src/store/mutations.js",\r\n         "src/store/state.js",\r\n         "src/utils/request.js",\r\n         "src/views/About.vue",\r\n         "src/views/Home.vue",\r\n       ];\r\n   \r\n       templates.forEach((item) => {\r\n         // item => 每个文件路径\r\n         this.fs.copyTpl(\r\n           this.templatePath(item),\r\n           this.destinationPath(item),\r\n           this.answers\r\n         );\r\n       });\r\n     }\r\n   };\r\n   ```\r\n\r\n7. 接着，我们把模板文件夹中的`public`文件夹下的`index.html`文件进行修改，如下：\r\n\r\n   ```html\r\n   <!DOCTYPE html>\r\n   <html lang="en">\r\n   \r\n   <head>\r\n     <meta charset="utf-8">\r\n     <meta http-equiv="X-UA-Compatible" content="IE=edge">\r\n     <meta name="viewport" content="width=device-width,initial-scale=1.0">\r\n     <!-- 这里要进行一个转移 -->\r\n     <link rel="icon" href="<%%= BASE_URL %>favicon.ico">\r\n     <title><%= name %></title>\r\n   </head>\r\n   \r\n   <body>\r\n     <noscript>\r\n       <strong>We\'re sorry but <%= name %> doesn\'t work properly without JavaScript enabled. Please enable it to\r\n         continue.</strong>\r\n     </noscript>\r\n     <div id="app"></div>\r\n     <!-- built files will be auto injected -->\r\n   </body>\r\n   \r\n   </html>\r\n   ```\r\n\r\n   模板文件中的要遵循`EJS`的语法\r\n\r\n8. 接着，我们在命令行中输入`yarn link`，把我们写的`Generator`挂载在全局，便于我们测试。\r\n\r\n   ```\r\n   yarn link # or npm link\r\n   ```\r\n\r\n9. 接着，我们在硬盘中新建一个目录，叫做`vue-test`。\r\n\r\n10. 进入到`vue-test`文件夹，输入`yo vue`，命令行会提示一个`your project name`，可以输入也可以不输入，不输入默认是获取当前目录名。\r\n\r\n    ```\r\n    yo vue\r\n    ```\r\n\r\n    <img width="682" alt="https://user-images.githubusercontent.com/19791710/84155333-cf6e0180-aa9a-11ea-9ce1-86c491346479.png" src="https://user-images.githubusercontent.com/19791710/84155333-cf6e0180-aa9a-11ea-9ce1-86c491346479.png">\r\n\r\n11. 输入完名称后，命令行会提示我们创建了哪些文件。\r\n\r\n    <img width="682" alt="https://user-images.githubusercontent.com/19791710/84155691-37244c80-aa9b-11ea-8265-57bb86832927.png" src="https://user-images.githubusercontent.com/19791710/84155691-37244c80-aa9b-11ea-8265-57bb86832927.png">\r\n\r\n12. 接着，我们进入`vue-test`目录，可以看到脚手架工具帮我们生产了模板文件\r\n\r\n13. 我们打开编辑器，打开`public`文件夹下的`index.html`文件，可以看到，内容已经是动态的了。\r\n\r\n    ![image](https://user-images.githubusercontent.com/19791710/84157831-c3377380-aa9d-11ea-81ff-4f1d79f90a63.png)\r\n\r\n这样我们一个自定义脚手架就完成了。\r\n\r\n## 发布 Generator\r\n\r\n发布一个`Generator`就是发布一个`npm`模块，发布步骤：\r\n\r\n1. 注册`npm`账号，并且检验电子邮箱，本地进行npm登录。\r\n\r\n   ```\r\n   yarn login\r\n   ```\r\n\r\n   \r\n\r\n2. 把代码托管在远程仓库上（`github`，`gitlab`,`gitee`）都行，不托管代码也是允许的。\r\n\r\n3. 通过`npm publish`或者`yarn publish`的方式发布一个模块，在命令行执行`yarn publish`,\r\n\r\n   ![image](https://user-images.githubusercontent.com/19791710/84347593-8e363880-abe5-11ea-810c-88b91b6129ef.png)\r\n\r\n   输入完命令后，会提示我们是否修改版本号，如果要修改就输入新的版本号，不修改按回车键，我这里不修改。\r\n\r\n4. 按回车键后，控制台会输出一个错误，如下：\r\n\r\n   ![image](https://user-images.githubusercontent.com/19791710/84347725-d2c1d400-abe5-11ea-9459-2674e6bb42e0.png)\r\n\r\n   这是因为，我们的yarn镜像设置成了国内的淘宝镜像了，淘宝镜像它只是一个只读的镜像，所以这里有两种解决方法，第一种就是切换回默认的源，接着在发布。第二种就是用默认源进行发布。\r\n\r\n   - 第一种，切换回默认源，接着在发布。\r\n\r\n     ```\r\n     yarn config set registry https://registry.yarnpkg.com \r\n     yarn publish\r\n     ```\r\n\r\n   - 第二种，使用默认源发布\r\n\r\n     ```\r\n     yarn publish --registry=https://registry.yarnpkg.com \r\n     ```\r\n\r\n5. 我使用第二种方式，**接着会提示输入用户名和密码，如果是第一次的话，需要登录注册的邮箱，校验npm的邮箱。**\r\n\r\n6. 等待一段时间后，命令行就会输出ok。\r\n\r\n   ![image](https://user-images.githubusercontent.com/19791710/84349631-4bc32a80-abea-11ea-82d7-39720f5af0d8.png)\r\n\r\n   我们去[npm](https://www.npmjs.com/)官网搜索`generator-aisen60-vue`，会看到我们的包已经发布成功了。\r\n\r\n   ![https://user-images.githubusercontent.com/19791710/84349817-b2484880-abea-11ea-913e-e9f7e4be1452.png](https://user-images.githubusercontent.com/19791710/84349817-b2484880-abea-11ea-913e-e9f7e4be1452.png)\r\n\r\n',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/10',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/10/labels{/name}',
    comments_url:
      'https://api.github.com/repos/Aisen60/blog/issues/10/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/10/events',
    html_url: 'https://github.com/Aisen60/blog/issues/10',
    id: 632236099,
    node_id: 'MDU6SXNzdWU2MzIyMzYwOTk=',
    number: 10,
    title: 'JavaScript性能优化',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1929142384,
        node_id: 'MDU6TGFiZWwxOTI5MTQyMzg0',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/JavaScript',
        name: 'JavaScript',
        color: 'fbca04',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 2,
    created_at: '2020-06-06T06:04:31Z',
    updated_at: '2020-07-13T01:34:55Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      "### 内存管理\r\n\r\n**内存管理是什么？**\r\n\r\n顾名思义内存管理就是对内存进行管理，和其它语言不一样的是，js中底层没有提供内存管理的接口。js在创建变量的时候就自动分配了内存，并且在这些变量不再使用的时候自动清除，这个过程也叫做**垃圾回收**。\r\n\r\n**为什么需要内存管理**\r\n\r\n随着目前前端项目越来越庞大，工程化越来越复杂，我们更加需要对内存进行管理。如果不进行内存管理，我们的程序会越用越卡，甚至会崩溃，造成的体验会很不友好。\r\n\r\n**js中的内存管理**\r\n\r\njs中的内存管理分为三步：\r\n- 申请内存空间\r\n- 使用内存空间\r\n- 释放内存空间\r\n\r\n**申请内存空间、使用内存空间**\r\n\r\n因为js没有提供内存管理的接口，所以js在创建变量的时候，自动就分配了内存空间，或者说自动申请到了内存空间。当把一个值赋值给变量```a```的时候，那么可以说是a使用了内存空间。\r\n```javaScript\r\nvar a;\r\na = 'xxx'\r\n```\r\n**释放内存空间**\r\n\r\n当变量不在被使用到的时候，那么```a```就会被释放掉或者说被自动清除，这个过程也叫做**垃圾回收**\r\n```javaScript\r\nfunction fn(){\r\n    var a = '1'; // a 是一个局部变量，当调用完fn后，这个变量就没有被用到了，就会被清除掉，或者说这个内存被释放了\r\n    console.log(a)\r\n}\r\nfn()\r\n```",
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/9',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/9/labels{/name}',
    comments_url: 'https://api.github.com/repos/Aisen60/blog/issues/9/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/9/events',
    html_url: 'https://github.com/Aisen60/blog/issues/9',
    id: 624359760,
    node_id: 'MDU6SXNzdWU2MjQzNTk3NjA=',
    number: 9,
    title: '函数式编程范式 学习笔记',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1929142384,
        node_id: 'MDU6TGFiZWwxOTI5MTQyMzg0',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/JavaScript',
        name: 'JavaScript',
        color: 'fbca04',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 3,
    created_at: '2020-05-25T15:15:33Z',
    updated_at: '2020-05-31T11:50:43Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      // eslint-disable-next-line no-template-curly-in-string
      '## 什么是函数式编程？\r\n函数式编程英文名叫```Functional Programming```,简称```FP```,FP是编程范式之一（就是编程风格之一）。\r\n**函数式编程就是对运算过程的抽象，函数式编程中的函数不是程序中的函数或者方法，而是数学中的函数（映射关系），它要求相同的输入有相同的输出。**\r\n\r\n### 在js中和函数式编程相关的概念\r\n- #### 函数是一等公民\r\n\r\n> 在js中函数就是一个普通的对象，我们可以把函数存储到变量、数组中，它还可以作为另外一个函数的参数和返回值，甚至我们可以在程序运行的时候通过```new Function(\'alert(1)\')```来构造一个新的函数。\r\n    \r\n   \r\n```javaScript\r\nlet fn = function () {\r\n  console.log("Hello Fitst-class Function");\r\n};\r\n\r\nfn();\r\n\r\n// 一个示例\r\n\r\nconst BlogController = {\r\n  index(post) {\r\n    return Views.index(post);\r\n  },\r\n  show(post) {\r\n    return Views.index(post);\r\n  },\r\n  create(post) {\r\n    return Db.create(post);\r\n  },\r\n  update(post) {\r\n    return Db.update(post);\r\n  },\r\n  destory(post) {\r\n    return Db.destory(post);\r\n  },\r\n};\r\n\r\n// 优化\r\n\r\n// 这里是把一个函数/方法赋值给另外一个方法，不是把函数的调用赋值给另外一个方法。\r\nconst BlogController = {\r\n  index: Views.index,\r\n  show: Views.show,\r\n  create: Db.index,\r\n  update: Db.index,\r\n  destory: Db.index,\r\n};\r\n\r\n```\r\n- #### 高阶函数(Higher-order function)\r\n    + **可以把函数作为参数**\r\n    \r\n        ```javaScript\r\n        // 高阶函数-函数作为参数\r\n        \r\n        function forEach(array, fn) {\r\n          for (let i = 0; i < array.length; i++) {\r\n            fn(array[i]);\r\n          }\r\n        }\r\n        \r\n        // 测试\r\n        let arr = [1, 2, 3, 4, 5];\r\n        \r\n        // 输出：1, 2, 3, 4, 5\r\n        forEach(arr, function (item) {\r\n          console.log(item);\r\n        });\r\n        \r\n        function filter(array, fn) {\r\n          let results = [];\r\n          for (let i = 0; i < array.length; i++) {\r\n            if (fn(array[i])) {\r\n              results.push(array[i]);\r\n            }\r\n          }\r\n          return results;\r\n        }\r\n        \r\n        // 测试\r\n        let arr1 = [1, 2, 3, 4, 5];\r\n        \r\n        let r = filter(arr1, function (item) {\r\n          debugger;\r\n          return item % 2 === 0;\r\n        });\r\n        \r\n        // 输出：[2,4]\r\n        console.log(r);\r\n\r\n        ```\r\n        \r\n        总结：根据上面的代码，我们会得出函数作为参数时的好处，会让我们的函数变得更加灵活\r\n        \r\n    + **函数作为返回值**\r\n        ```javaScript\r\n        // 高阶函数-函数作为返回值\r\n\r\n        function makeFn() {\r\n          let msg = "Hello function";\r\n          return function () {\r\n            console.log(msg);\r\n          };\r\n        }\r\n        \r\n        const fn = makeFn();\r\n        fn();\r\n        \r\n        // once 函数，只执行一次的函数，在支付场景用的比较多。\r\n        function once(fn) {\r\n          let done = false;\r\n          return function () {\r\n            if (!done) {\r\n              return fn.apply(this, arguments);\r\n            }\r\n          };\r\n        }\r\n        \r\n        let pay = once(function (money) {\r\n          console.log(`支付: ${money} RMB`);\r\n        });\r\n\r\n        ```\r\n        \r\n    + **高阶函数的意义**\r\n        + 抽象可以帮我们屏蔽细节，只需要关注与我们的目标\r\n        + 高阶函数是用来抽象通用的问题\r\n    \r\n    + **常用的高阶函数**\r\n        \r\n        对数组中map、every、some方法进行了编写练习。\r\n        \r\n        ```javaScript\r\n        // 模拟常用的高阶函数：map、every、some\r\n\r\n        const map = (array, fn) => {\r\n          let arr = [];\r\n        \r\n          for (let value of array) {\r\n            arr.push(fn(value));\r\n          }\r\n        \r\n          return arr;\r\n        };\r\n        \r\n        const every = (array, fn) => {\r\n          let result = true;\r\n        \r\n          for (let value of array) {\r\n            if (!fn(value)) {\r\n              result = false;\r\n              break;\r\n            }\r\n          }\r\n        \r\n          return result;\r\n        };\r\n        \r\n        const some = (array, fn) => {\r\n          let result = false;\r\n        \r\n          for (let value of array) {\r\n            if (fn(value)) {\r\n              result = true;\r\n              break;\r\n            }\r\n          }\r\n        \r\n          return result;\r\n        };\r\n\r\n        ```\r\n        \r\n- 闭包\r\n    + 函数和其周围的状态（词法环境）的引用捆绑在一起形成的闭包。\r\n    + 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。\r\n    ```javaScript\r\n        function makePower(power) {\r\n            return function (number) {\r\n                return Math.pow(number, power)\r\n            }\r\n        }\r\n\r\n        let power2 = makePower(2)\r\n        // let power3 = makePower(3)\r\n\r\n        console.log(power2(4))\r\n        // console.log(power2(5))\r\n        // console.log(power3(4))\r\n    ```\r\n    上面这个例子就是通过闭包来实现对一个数进行求平方的功能。```makePower```函数接收一个参数，这个参数是多少次密，并且返回一个函数，这个函数接收一个数字，并且执行求密。\r\n    \r\n    下面是通过浏览器控制台来调试一下这段代码。\r\n    \r\n    我们在``` let power2 = makePower(2) ```这一行中加了一个断点，这个时候我们可以看到**Call Stack**调用栈中执行了这个匿名函数，并且在**Scope**作用域中看到了一个全局的**Global**变量，这个变量就是指向window。我们按F11进行下一步的调试。\r\n    \r\n    ![image](https://user-images.githubusercontent.com/19791710/83320521-fc403e80-a27a-11ea-90b5-45d43a0d8568.png)\r\n    \r\n    接着，执行到了**makePower**函数中，在**Call Stack**执行栈中，**makePower**函数被压入执行栈中被执行了，并且在**Scope**作用域中看到了一个**power**变量，它的值是**2**，并且还有一个内部的this，它指向了全局的window。我们按F11进行下一步的调试。\r\n    \r\n    ![image](https://user-images.githubusercontent.com/19791710/83320557-5e993f00-a27b-11ea-8fb3-afb2a57ef233.png)\r\n    \r\n    这个时候**Scope**作用域中多了一个**Renturn value**的变量，他是一个函数。我们按F11进行下一步的调试。\r\n    \r\n    ![image](https://user-images.githubusercontent.com/19791710/83320659-19294180-a27c-11ea-9177-8de45cab939e.png)\r\n    \r\n    这个时候执行到了```console.log(power2(4))```中，在执行栈中被压入执行了，我们按F11进行下一步的调试。\r\n    \r\n    这个时候，我们在执行栈中看到返回的```makePower```返回的函数被压入到执行栈中执行了，并且在**Scope**作用域中看到，有一个```Closure```闭包，它里面有一个名为```power```的变量，并且值为4。这个时候就执行了**power**和**number**的求密运算。\r\n    \r\n    **这也证实了闭包可以在可以访问另外一个函数作用域中的变量，因为在另外一个函数作用域中会把闭包所使用到的变量缓存下来。**\r\n    \r\n    ![image](https://user-images.githubusercontent.com/19791710/83320693-6c02f900-a27c-11ea-838e-341f58181f64.png)\r\n\r\n\r\n\r\n\r\n',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/8',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/8/labels{/name}',
    comments_url: 'https://api.github.com/repos/Aisen60/blog/issues/8/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/8/events',
    html_url: 'https://github.com/Aisen60/blog/issues/8',
    id: 623000847,
    node_id: 'MDU6SXNzdWU2MjMwMDA4NDc=',
    number: 8,
    title: 'TypeScript 学习笔记',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 2079954605,
        node_id: 'MDU6TGFiZWwyMDc5OTU0NjA1',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/TypeScript',
        name: 'TypeScript',
        color: '3884FF',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 8,
    created_at: '2020-05-22T07:03:30Z',
    updated_at: '2020-05-24T05:01:24Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '## 安装ts\r\n\r\n- 首先安装ts的模块，可以安装到全局，或者本项目。\r\n```\r\nyarn init --yes // 先通过yarn初始化项目\r\nyarn add typescript --dev 安装ts\r\n```\r\n- 这个模块提供了一个tsc的命令，可以通过这个命令编译ts文件。\r\n```\r\nyarn tsc test.ts\r\n```\r\n- 编译过程中，会先去检查代码中的类型使用异常，移除类型注解还有一些扩展语法，\r\n- 在这个过程中会去转换es的新特性，并且把ts代码编译成es3（默认）的代码。\r\n\r\n\r\n\r\n## ts配置文件\r\n\r\n通过命令：yarn tsc --int 来生产ts配置文件，并且会在项目根目录下生产tsconfig.json的文件\r\n\r\n生成的文件里面有很多配置项，请看tsconfig.json\r\n\r\n下面是对tsconfig.json配置文件一些配置选项的说明，用到了什么就先记录什么。\r\n\r\n```javaScript\r\n {\r\n    "target": "es5",                // 需要将ts代码转换成那个版本的es，默认是es3版本的\r\n    "module": "commonjs",           // 输出的代码采用什么方式进行模模块化\r\n    "lib": [],                      // 所使用的标准库\r\n    "sourceMap": true,              // 开启源代码映射，方便调试，开启后可调试ts的代码\r\n    "outDir": "dist",               // 转换后的js代码存放的路径\r\n    "rootDir": "src",               // 项目所需要编译的文件夹，配置了这个选项后，执行 yarn tsc 会把当前这个目录下的所有ts文件编译成js文件，并且存放到outDir所配置的文件夹下。\r\n    "strict": true,                 // 是否开启严格模式（所有的，包括常量变量类型）\r\n    "strictNullChecks": true,       // 如果只是检查所有变量不能为空的话，把"strict"设置为false，把当前选项设置成true，就只会检查所有的变量是否为空。\r\n}\r\n```\r\n\r\n**下面是ts配置文件源码**\r\n```javaScript\r\n{\r\n  "compilerOptions": {\r\n    /* Visit https://aka.ms/tsconfig.json to read more about this file */\r\n\r\n    /* Basic Options */\r\n    // "incremental": true,                   /* Enable incremental compilation */\r\n    "target": "es5",                          /* Specify ECMAScript target version: \'ES3\' (default), \'ES5\', \'ES2015\', \'ES2016\', \'ES2017\', \'ES2018\', \'ES2019\', \'ES2020\', or \'ESNEXT\'. */\r\n    "module": "commonjs",                     /* Specify module code generation: \'none\', \'commonjs\', \'amd\', \'system\', \'umd\', \'es2015\', \'es2020\', or \'ESNext\'. */\r\n    "lib": ["ES2015","DOM","ES2017"],                             /* Specify library files to be included in the compilation. */\r\n    // "allowJs": true,                       /* Allow javascript files to be compiled. */\r\n    // "checkJs": true,                       /* Report errors in .js files. */\r\n    // "jsx": "preserve",                     /* Specify JSX code generation: \'preserve\', \'react-native\', or \'react\'. */\r\n    // "declaration": true,                   /* Generates corresponding \'.d.ts\' file. */\r\n    // "declarationMap": true,                /* Generates a sourcemap for each corresponding \'.d.ts\' file. */\r\n    "sourceMap": true,                     /* Generates corresponding \'.map\' file. */\r\n    // "outFile": "./",                       /* Concatenate and emit output to single file. */\r\n    "outDir": "dist",                        /* Redirect output structure to the directory. */\r\n    "rootDir": "src",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */\r\n    // "composite": true,                     /* Enable project compilation */\r\n    // "tsBuildInfoFile": "./",               /* Specify file to store incremental compilation information */\r\n    // "removeComments": true,                /* Do not emit comments to output. */\r\n    // "noEmit": true,                        /* Do not emit outputs. */\r\n    // "importHelpers": true,                 /* Import emit helpers from \'tslib\'. */\r\n    // "downlevelIteration": true,            /* Provide full support for iterables in \'for-of\', spread, and destructuring when targeting \'ES5\' or \'ES3\'. */\r\n    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to \'ts.transpileModule\'). */\r\n\r\n    /* Strict Type-Checking Options */\r\n    // "strict": true,                           /* Enable all strict type-checking options. */\r\n    // "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied \'any\' type. */\r\n    // "strictNullChecks": true,              /* Enable strict null checks. */\r\n    // "strictFunctionTypes": true,           /* Enable strict checking of function types. */\r\n    // "strictBindCallApply": true,           /* Enable strict \'bind\', \'call\', and \'apply\' methods on functions. */\r\n    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */\r\n    // "noImplicitThis": true,                /* Raise error on \'this\' expressions with an implied \'any\' type. */\r\n    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */\r\n\r\n    /* Additional Checks */\r\n    // "noUnusedLocals": true,                /* Report errors on unused locals. */\r\n    // "noUnusedParameters": true,            /* Report errors on unused parameters. */\r\n    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */\r\n    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */\r\n\r\n    /* Module Resolution Options */\r\n    // "moduleResolution": "node",            /* Specify module resolution strategy: \'node\' (Node.js) or \'classic\' (TypeScript pre-1.6). */\r\n    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */\r\n    // "paths": {},                           /* A series of entries which re-map imports to lookup locations relative to the \'baseUrl\'. */\r\n    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */\r\n    // "typeRoots": [],                       /* List of folders to include type definitions from. */\r\n    // "types": [],                           /* Type declaration files to be included in compilation. */\r\n    // "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */\r\n    "esModuleInterop": true,                  /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies \'allowSyntheticDefaultImports\'. */\r\n    // "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */\r\n    // "allowUmdGlobalAccess": true,          /* Allow accessing UMD globals from modules. */\r\n\r\n    /* Source Map Options */\r\n    // "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */\r\n    // "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */\r\n    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */\r\n    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires \'--inlineSourceMap\' or \'--sourceMap\' to be set. */\r\n\r\n    /* Experimental Options */\r\n    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */\r\n    // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */\r\n\r\n    /* Advanced Options */\r\n    "skipLibCheck": true,                     /* Skip type checking of declaration files. */\r\n    "forceConsistentCasingInFileNames": true  /* Disallow inconsistently-cased references to the same file. */\r\n  }\r\n}\r\n```',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/7',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/7/labels{/name}',
    comments_url: 'https://api.github.com/repos/Aisen60/blog/issues/7/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/7/events',
    html_url: 'https://github.com/Aisen60/blog/issues/7',
    id: 619118879,
    node_id: 'MDU6SXNzdWU2MTkxMTg4Nzk=',
    number: 7,
    title: 'ECMAScript 新特性学习笔记',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1929142384,
        node_id: 'MDU6TGFiZWwxOTI5MTQyMzg0',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/JavaScript',
        name: 'JavaScript',
        color: 'fbca04',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 4,
    created_at: '2020-05-15T17:08:00Z',
    updated_at: '2020-05-22T06:36:09Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '## 数组解构\r\n\r\n### 获取数组成员的不同\r\n\r\n下面有一个数组，以往的话，如果要获取数组中的某个值，都是根据下标去获取。\r\n\r\n```javaScript\r\nconst arr = [100, 200, 300];\r\n\r\nconst foo = arr[0];\r\nconst bar = arr[1];\r\nconst baz = arr[2];\r\n```\r\n    \r\n现在可以通过解构的这种方式快速的获取数组成员，具体的用法就是，把以前定义变量名的地方修改为一个数组的方括号，方括号里面就是我们需要提取出来的数据所存放的变量名，数组的内部就会按照顺序分配相对应的数据给到指定的变量名。\r\n    \r\n```javaScript\r\nconst arr = [100, 200, 300];\r\nconst [foo, bar, baz] = arr;\r\nconsole.log(foo, bar, baz);\r\n```\r\n\r\n上面输出的结果为：100，200，300。\r\n\r\n如果结构的成员个数小于数组的长度，会按照从前往后的顺序提取。\r\n\r\n反之，结构的成员个数大于数组的长度,那么提取到的就是undefined。\r\n\r\n### 获取数组指定成员\r\n\r\n如果要获取数组中指定位置的成员，可以这样写：\r\n\r\n```javaScript\r\nconst arr = [100, 200, 300];\r\nconst [, , baz] = arr;\r\nconsole.log(baz);\r\n```\r\n上面输出的结果为：300。\r\n\r\n要确保结构位置的格式和数组是一致的。\r\n\r\n例如我只想获取数组的第三个成员，那么要保留前面的2个逗号。这样就能提出到相对应的成员。\r\n\r\n### 提取从当期位置开始往后的所有成员\r\n\r\n可以在变量名前面加三个点，表示获取从当前位置开始往后的所有成员，所有的结果会被放到一个数组中。\r\n\r\n```javaScript\r\nconst arr = [100, 200, 300];\r\nconst [foo, ...other] = arr;\r\nconsole.log(foo, other);\r\n```\r\n\r\n上面输出的结果为：100 [ 200, 300 ]。\r\n\r\n### 为提取的成员设置默认值\r\n\r\n可以为提取的成员设置默认值，如果数组中没有提取到，那么就是设置的默认值，如果有那么就是数组的值。\r\n\r\n\r\n```javaScript\r\nconst arr = [100, 200, 300];\r\nconst [foo, bar, baz = 123, more = "defaule value"] = arr;\r\nconsole.log(foo, bar, baz, more);\r\n```\r\n\r\n上面输出的结果为：100 200 300 defaule value。\r\n\r\n这种语法呢，在很多情况下能带给我们很多的便捷，比如说要拆分一个字符串，获取指定的位置。\r\n\r\n之前的写法：\r\n\r\n```javaScript\r\nconst path = \'/foo/bar/baz\'\r\nconst tmp = path.split("/")[1];\r\nconsole.log(tmp);\r\n```\r\n输出：foo\r\n\r\n现在的写法：\r\n\r\n```javaScript\r\nconst path = "/foo/bar/baz";\r\nconst [, tmp] = path.split("/");\r\nconsole.log(tmp);\r\n```\r\n输出：foo',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/6',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/6/labels{/name}',
    comments_url: 'https://api.github.com/repos/Aisen60/blog/issues/6/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/6/events',
    html_url: 'https://github.com/Aisen60/blog/issues/6',
    id: 614778238,
    node_id: 'MDU6SXNzdWU2MTQ3NzgyMzg=',
    number: 6,
    title: 'vue keep-alive 移动端返回到指定位置',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1929143897,
        node_id: 'MDU6TGFiZWwxOTI5MTQzODk3',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/Vue',
        name: 'Vue',
        color: '42b983',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-05-08T14:29:03Z',
    updated_at: '2020-05-08T14:34:24Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '最近公司项目有个需求，有一个列表页面，点击列表中的某一项进入到详情页面，详情页面点击返回后要返回到列表页面的原来的位置，并且是列表页面无刷新的，不在请求数据。\r\n\r\n问题一、返回到列表页面，并且无刷新。\r\n\r\n使用 keep-alive 缓存列表组件，这样就解决了不在重复请求的问题了。\r\n\r\n记录下 kee-alive 的坑: 没详情看文档，一直以为 include 存的是路由的 name，实际上 include 这个参数匹配的是组件的 name，而不是路由的 name。\r\n\r\nApp.vue:\r\n\r\n```jsx\r\n<template>\r\n  <div id="app">\r\n    <keep-alive :include="aliveComponents">\r\n      <router-view />\r\n    </keep-alive>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      // 需要keep-alive的组件,存的是组件的name，而不是路由的name\r\n      aliveComponents: ["page1", "page2"]\r\n    };\r\n  }\r\n};\r\n</script>\r\n```\r\n\r\npage1.vue:\r\n```jsx\r\n<template>\r\n  <div class="page1" style="padding:20px">\r\n    <div\r\n      style="border: 1px solid #cecece;padding: 10px;margin-bottom:10px"\r\n      v-for="i in 20"\r\n      :key="i"\r\n    >\r\n      <router-link to="/page2">{{i}}、{{Math.random()}}</router-link>\r\n    </div>\r\n    <router-link to="/page2">page to page2</router-link>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: "page1",\r\n\r\n  created() {\r\n    console.log("page1");\r\n  },\r\n\r\n  mounted() {}\r\n};\r\n</script>\r\n```\r\n\r\npage2.vue:\r\n```jsx\r\n<template>\r\n  <div class="page2">\r\n    <p>page2</p>\r\n    <router-link to="/page1">page to page2</router-link>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: "page2",\r\n  created() {\r\n    console.log("page2");\r\n  }\r\n};\r\n</script>\r\n```\r\n\r\n问题二、详情页面点击返回后要返回到列表页面的原来的位置。\r\n\r\n想法是当离开了列表页面，进入到详情页面时，在路由守卫记录下列表页面的滚动高度，存到vuex。\r\n\r\n我这里为了做demo，把滚动条高度存到了localStorage，而且代码会相对简陋。\r\n\r\n```jsx\r\nimport router from "./router/";\r\n\r\nrouter.beforeEach((to, from, next) => {\r\n  // 如果目标路由是详情页面，并且离开的路由是列表页面，那么记录下当前的列表页面的滚动条高度  \r\n  if (to.name === "page2" && from.name === "page1") {\r\n    const scrollTop = document.querySelector("#app").scrollTop;\r\n    localStorage.setItem("scrollTop", scrollTop);\r\n  } \r\n  // 如果不是，那么设置容器app的滚动条高度。\r\n  // 加个setTimeout定时器的原因是想让线程往后执行，因为当前路由还没进入到page1，缓存的组件还未被激活，设置的滚动是无效的。\r\n  else {\r\n    const scrollTop = localStorage.getItem("scrollTop");\r\n    setTimeout(() => {\r\n      document.querySelector("#app").scrollTop = scrollTop;\r\n      localStorage.removeItem("scrollTop");\r\n    }, 0);\r\n  }\r\n  //...\r\n  next();\r\n});\r\n```\r\n\r\n效果图如下：\r\n\r\n![很模糊的gif图](https://user-images.githubusercontent.com/19338152/81415124-97615f00-917a-11ea-88af-6208f4822a14.gif)\r\n',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/5',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/5/labels{/name}',
    comments_url: 'https://api.github.com/repos/Aisen60/blog/issues/5/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/5/events',
    html_url: 'https://github.com/Aisen60/blog/issues/5',
    id: 602631139,
    node_id: 'MDU6SXNzdWU2MDI2MzExMzk=',
    number: 5,
    title: '我对git分支流程的使用',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1721385519,
        node_id: 'MDU6TGFiZWwxNzIxMzg1NTE5',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/good',
        name: 'good',
        color: 'ae8a53',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-04-19T05:57:26Z',
    updated_at: '2020-04-19T05:57:26Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '### 前言\r\n\r\n还记得刚毕业出来去一家企业实习的时候，开发团队也只有7个人，代码管理系统用的是svn，后来过了一段时间，改成了git。当时使用git的时候没有进行很好的代码管理，只有master分支。所以会经常出现代码覆盖，版本很难回滚，很难定位到bug所在的版本，并且有新的需求就往上加，导致对代码的管理很困难，也导致了项目迭代的困难。后来我实习结束离开的时候，依旧没有解决这个问题。\r\n\r\n后来我去到新的企业，也有这种现象存在，大概过了2个月左右，来了新的总监。总监对代码管理和项目管理比较看重，制订了一套规范和流程。后来才慢慢的对git的使用有了比较深的理解。\r\n\r\n### 分支的介绍\r\n\r\n图片来源于：[https://nvie.com/posts/a-successful-git-branching-model/](https://note.youdao.com/)\r\n\r\n![分支模型](https://nvie.com/img/git-model@2x.png)\r\n\r\n我在平时的工作中和学习中主要使用到的分支：\r\n\r\n**master**\r\n- 这个分支的代码是目前生产环境运行的代码。\r\n- 这个分支的代码一般是由develop分支和hotfix分支合拼完成的。\r\n- 这个分支的代码是不能在任何时间修改的。要保持master分支的稳定性。\r\n\r\n**develop**\r\n- 这个分支的代码始终是项目的最新代码，包含了完成新功能的开发和bug的修改。\r\n\r\n**feature**\r\n- 这个分支的代码主要是新功能的开发。\r\n- feature分支是以develop分支为基础创建的。\r\n- 命名分支：一般以feature/开头，例如：feature/module、feature/content。公司项目我都是以feature/姓名拼音全称，这样命名。\r\n\r\n**release**\r\n- 这个分支的代码是预上线代码，提交测试阶段，会以release分支代码为基准提测。\r\n\r\n    \r\n    当新的功能开发完成后，由feature分支合拼到develop分支，进入提测时，会以develop分支为基础创建release分支。\r\n    \r\n    release分支的命名一般以release/开头，后面加上模块名或者日期。\r\n    \r\n    如果测试过程中有bug需要修复，那么直接在release分支修复，并且提交测试。\r\n    \r\n    当测试完成后，把release分支的代码合拼到master和develop分支。\r\n    \r\n    此时master分支用于部署生产环境的代码。\r\n    \r\n    tips:因为release分支是由develop分支为基础的所创建的，测试完成后，可以认为达到了生产环境的版本了。\r\n    \r\n    \r\n**hotfix**\r\n- 这个分支的代码主要是解决线上的紧急bug的，以master分支为基础创建的，命名的规则可以和feature一样。\r\n- 当解决完bug后，需要合拼到master分支和develop分支。\r\n\r\n\r\n### 场景设想\r\n\r\n1、老大安排了新的需求，需要做一个用户系统，要求一周内完成并且需要部署上线。你看看有没有当期有没有新需求的分支（多人协作，有可能你的同事已经创建了），如果没有那就创建一个feature分支，命名为"feature/user_module"。如果有当前分支了，那不用创建直接拉取当前这个代码的分支。\r\n\r\n2、3天过去了，你做完了这个新的需求，自己也自测通过了，需要提交测试了。首先，先把feature/user_module合拼到develop分支。合拼完后，在以develop分支为基础创建release分支，命名为"release/user_module"。创建这个release/user_module分支的目的是为了解决测试所提出的bug。\r\n\r\n3、测试人员提出了好几个bug，然后在release/user_module分支上修改，修改完后在此提测。如果还有bug那么也在这个分支上修改提测。一直到没有bug了。\r\n\r\n4、一周来到了最后一天晚上了，老大说准备部署生产环境了。这个时候就可以把release/user_module分支合拼到master和develop分支上了。部署之前，老大会打一个tag标签，以便回退到当前的这个版本。\r\n\r\n5、做完了这个需求，下面或许还有很多需求，那么可以继续按照上面的流程来。\r\n\r\n6、第二天或者第n天后，客户反馈有个bug或者有个按钮或者数据出不来，你定位到了问题后，也与团队内的同事或者老大确认过后，需要紧急处理。这个时候以master为基础创建hotfix分支，命名为"hotfix/user_module"分支，修改并且验证完这个bug后，把代码合拼到master和develop分支上，部署之前打个tag，并且部署生产环境。\r\n\r\n**上面的分支流程是我在平时工作和学习中所使用的，每个企业和团队的流程大大小小的都不同，但是整体的流程都差不多。如果你的企业团队有分支流程规范，那么应该按照规范来走。**',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/4',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/4/labels{/name}',
    comments_url: 'https://api.github.com/repos/Aisen60/blog/issues/4/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/4/events',
    html_url: 'https://github.com/Aisen60/blog/issues/4',
    id: 596683086,
    node_id: 'MDU6SXNzdWU1OTY2ODMwODY=',
    number: 4,
    title: '我在写blog的时候用到的github api接口',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1929142384,
        node_id: 'MDU6TGFiZWwxOTI5MTQyMzg0',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/JavaScript',
        name: 'JavaScript',
        color: 'fbca04',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-04-08T15:53:07Z',
    updated_at: '2020-05-29T08:05:16Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      '受到了朋友的启发，用在github issues来写博客，在翻阅了一下朋友的blog看到了一些api接口。于是上google查了一下，github官方确实有相关的api。\r\n\r\n### 申请token\r\n如果没有任何授权直接访问的话，单IP每小时只能有60次的请求。如果授权了的话，每小时可达到5000次的请求。\r\n\r\n文档还介绍了，在响应头response headers中返回了**X-RateLimit-Limit**和**X-RateLimit-Remaining**。这2个字段分别代表着当前剩余的访问次数和当前每小时限次。\r\n![image](https://user-images.githubusercontent.com/19791710/78806173-eccc1400-79f4-11ea-8fa8-b1ac5dd90921.png)\r\n\r\n如果想要获得更多的访问次数以及更大的限次，可以申请token来解决。下面是我在做blog的时候用到的授权方式，**OAuth2 token**。\r\n\r\n**申请token步骤**\r\n\r\n1. 进入github，个人设置页面，Personal settings。\r\n![image](https://user-images.githubusercontent.com/19791710/78801670-8d1f3a00-79ef-11ea-9469-56236ced7a73.png)\r\n\r\n2. 点击左侧菜单栏最下方，Developer settings。\r\n![image](https://user-images.githubusercontent.com/19791710/78801788-ad4ef900-79ef-11ea-9495-a90ef728ccb0.png)\r\n\r\n3. 点击个人token，Personal access tokens\r\n![image](https://user-images.githubusercontent.com/19791710/78802016-e71fff80-79ef-11ea-9522-dd0859b4ae1c.png)\r\n\r\n4. 点击创建一个新的toekn，Generate new token\r\n![image](https://user-images.githubusercontent.com/19791710/78802123-04ed6480-79f0-11ea-96df-831f30678aa9.png)\r\n\r\n5. 输入github密码，进入到创建token页面，输入token名称，勾选权限。（如果只是做blog的话，个人建议还是只勾选读取的权限。）\r\n![image](https://user-images.githubusercontent.com/19791710/78802544-86dd8d80-79f0-11ea-8654-6115dba41725.png)\r\n\r\n输入完token名称、勾选完权限后，点击Generate token就可以了，这样token就创建好了。创建成功后，一定要保存这个token，github默认只会给你看一次这个token，下次打开页面或者刷新页面这个token就不见了。如果忘记了可以重新生成一个新的token。\r\n\r\n**token的注意事项**\r\n\r\n1. token的权限，如果只是做blog的话，像我这样，建议只设置读取的权限。在勾选权限的时候会有可选的，如果你全部都勾选了，一旦这个token暴露了，被别人知道了，别人就可以拿这个token调用相关的api把你的所有东西都修改或者直接删掉repo了。\r\n\r\n2. token字符串不能提交到github仓库里面，如果你提交了，github会把你这个token删掉。我试过几次，把token提交到github的repo上，github就给我邮箱发了邮件，那个邮件的意思大概说是不能暴露这个token。那请求github api的时候要用到这个token，怎么办？**我的做法是，把这个token拆分成数组，然后使用过的时候直接拼接起来**。当然了有很多方法，主要不完全暴露就行。\r\n\r\n**使用token**\r\n请求github api接口的时候，放在请求头上就可以了。官网是这样介绍的\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/78804313-9231b880-79f2-11ea-9c86-ed78d39a635c.png)\r\n\r\n![image](https://user-images.githubusercontent.com/19791710/78804455-bab9b280-79f2-11ea-9aad-6e9c0f8b3a15.png)\r\n\r\n### 我使用到的api\r\n1. `GET https://api.github.com/users/:username` 获取个人用户信息\r\n2. `GET https://api.github.com/users/:username/repos` 获取当前用户所有的仓库\r\n3. `GET https://api.github.com/repos/:username/:repos/labels` 获取某个仓库下的所有标签\r\n4. `GET https://api.github.com/repos/:username/:repos/issues` 获取某个仓库下的所有issues\r\n    - `GET https://api.github.com/repos/:username/:repos/issues?state=状态` 获取issues状态，open打开，close关闭。 \r\n    - `GET https://api.github.com/repos/:username/:repos/issues?labels=标签名`获取指定标签的所有issues。\r\n    - `GET https://api.github.com/repos/:username/:repos/issues?page=页数&per_page=每页包含数量` 分页功能，获取指定的issues数量。\r\n5. `GET https://api.github.com/repos/:username/:repos/issues/: issue_number`根据issues的 number获取详情 \r\n6. `GET https://api.github.com/repos/:username/:repos/contents/:path` 获取一个原始文件的内容。我的blog主要是获取md文件的，在请求头Request Headers上我加上了这一句`Accept:application/vnd.github.VERSION.html`就能返回可直接渲染的html文本了。如果不加这句话，会返回以下的格式\r\n```\r\n{\r\n    "name": "timeline.md",\r\n    "path": "timeline.md",\r\n    "sha": "1f45c2bf90e5362fb11c7f069ea995a398412a04",\r\n    "size": 1709,\r\n    "url": "https://api.github.com/repos/Aisen60/blog/contents/timeline.md?ref=master",\r\n    "html_url": "https://github.com/Aisen60/blog/blob/master/timeline.md",\r\n    "git_url": "https://api.github.com/repos/Aisen60/blog/git/blobs/1f45c2bf90e5362fb11c7f069ea995a398412a04",\r\n    "download_url": "https://raw.githubusercontent.com/Aisen60/blog/master/timeline.md",\r\n    "type": "file",\r\n    "content": "IyDwn5K76YeM56iL56KRCgojIyMjIyAyMDIwLTA0LTA5IDAwOjAwOjAxCi0g\\n5re75Yqg5LqGIFvmiJHlnKjlhplibG9n55qE5pe25YCZ55So5Yiw55qEZ2l0\\naHViIGFwaeaOpeWPo++8iOayoeWGmeWujO+8iV0oaHR0cHM6Ly9naXRodWIu\\nY29tL0Fpc2VuNjAvYmxvZy9pc3N1ZXMvNCkKCiMjIyMjIDIwMjAtMDQtMDcg\\nMjI6NTI6MDAKCi0g5LuK5aSp5oqKdGltZWxpbmXpobXpnaLlgZrkuobvvIzl\\ngZrov5nkuKp0aW1lbGluZeeahOaXtuWAme+8jOiwg+eUqGdpdGh1YueahOaO\\npeWPo+S8muaKpei3qOWfn+mXrumimOeahOmUmeivr++8jOWQjuadpeWPkeeO\\nsOiwg+eUqOmUmeaOpeWPo+S6hu+8jOeEtuWQjuWcqOiKseWcqOino+Wvhuea\\nhOaXtumXtOS4iuavlOi+g+Wkmu+8jOWGjeWQjuadpeagueacrOWwseS4jeeU\\nqOino+Wvhu+8jOWumOaWueacieaWh+aho+OAggoKLSDnlLHkuo7miJHnmoTp\\nmL/ph4zkupHmnI3liqHlmajmmK/lm73lhoXnmoTvvIzorr/pl65naXRodWLl\\nvojkuI3nqLPlrprvvIznhLblkI7miJHlsLHnlKjkuoZub3cuc2jmnaXpg6jn\\nvbLvvIzpgJ/luqbnm7jlr7nmnaXor7Tov5jov4flvpfljrvjgIJibG9nLXZ1\\nZeWcsOWdgO+8mltodHRwczovL2Fpc2VuNjAubm93LnNoXShodHRwczovL2Fp\\nc2VuNjAubm93LnNoKQoKIyMjIyMgMjAyMC0wNC0wNCAyMjoxMzowMAoKLSBi\\nbG9nLXZ1ZSDlgZrlrozkuobvvIzlnKjmuIXmmI7lgYfmnJ/mlL7lgYfnrKzk\\nuIDlpKnvvIzmiopibG9n5Ymp5LiL55qE5Lic6KW/6YO95YGa5LqG77yM5YyF\\n5ousbmdpbnjnmoTvvIzlnKjlronoo4VuZ2lueOeahOaXtuWAme+8jOi4qeS6\\nhuS4gOS6m+Wdke+8jOiKseS6huWkp+amgjLkuKrlsI/ml7bnoJTnqbbkuobk\\nuIvvvIznrpfmmK/op6PlhrPkuobvvIzljp/mnaXmmK/ot6/lirLnmoTpl67p\\nopjvvIzlrrPmiJHph43oo4XkuoYy5qyh57O757uf44CC6L+Y6ZyA6KaB6Iqx\\n5pe26Ze06Kej5Yaz5LiA5LiL77yM6LCD5LyY6Zeu6aKY77yM6L+Y5pyJYWJv\\ndXQgbWXjgIF0aW1lbGluZeebruW9leayoeWBmuOAguOAgn5+YmxvZy12dWXl\\nnLDlnYDvvJpbaHR0cDovL2Jsb2cuY2FpeHVzaGVuZy5jb21dKGh0dHA6Ly9i\\nbG9nLmNhaXh1c2hlbmcuY29tKeOAgn5+CgojIyMjIyAyMDIwLTAzLTIzIDIz\\nOjU4OjAwCgotIOWIm+W7uuS6hmJsb2ctdnVl6L+Z5Liq5LuT5bqT77yM5bm2\\n5LiU5Yid5aeL5YyW5LqG6aG555uu44CC55yL5LqG5LiA5LiLZ2l0aHViIGFw\\naeeahOaOpeWPo++8jOacieW/heimgeS6huino+S4gOS4i++8jOS8muWGmeS4\\nquWmguS9leS9v+eUqGdpdGh1YiBhcGnnmoTlrabkuaDnrJTorrAg44CCCgoj\\nIyMjIyAyMDIwLTAzLTIyIDIyOjMwOjAwCgotIOS7k+W6k+WIm+W7uuWlveS6\\nhizkuYvliY3mmK/lnKhbaHR0cHM6Ly9naXRodWIuY29tL0Fpc2VuNjAvYWlz\\nZW42MC5naXRodWIuaW9dKGh0dHBzOi8vZ2l0aHViLmNvbS9BaXNlbjYwL2Fp\\nc2VuNjAuZ2l0aHViLmlvKeWGmeS4gOS6m+aWh+eroOaIluiAheWtpuS5oOes\\nlOiusOeahO+8jOWQjuadpeWPiOWIsOS6huiHquW3seWOu+WcqOaciemBk+S6\\nkeeslOiusOS4iuWGmeeslOiusO+8jOmDveaYr+S4gOS6m+mbtumbtueijuei\\njueahOS4nOilv++8jOi/meWHoOWkqeS8muaAu+e7k+S4gOS6m+i/geenu+i/\\nh+adpe+8jOS8sOiuoei/meS4quaciOaciOW6leS8muWHuuS4quWNmuWuoumm\\nlumhte+8jOesrOS4gOeJiOaJk+eul+WFiOeUqHZ1ZeadpeWunueOsOOAggo=\\n",\r\n    "encoding": "base64",\r\n    "_links": {\r\n        "self": "https://api.github.com/repos/Aisen60/blog/contents/timeline.md?ref=master",\r\n        "git": "https://api.github.com/repos/Aisen60/blog/git/blobs/1f45c2bf90e5362fb11c7f069ea995a398412a04",\r\n        "html": "https://github.com/Aisen60/blog/blob/master/timeline.md"\r\n    }\r\n}\r\n```\r\n我一开始就是用这种`decodeURIComponent(escape(window.atob(content)));`来解密的拿到原始内容，这个content是通过base64加密的，后来查阅了一些资料和官方文档，直接在request headers上加上这句话`Accept:application/vnd.github.VERSION.html`就能返回可渲染的html内容。\r\n\r\n7. `GET https://api.github.com/repos/:owner/:repo/issues/:number/comments` 获取指定的issues下的所有的评论\r\n\r\n**还有很多api，如果以后使用到了，会继续补充哈。**',
    performed_via_github_app: null,
  },
  {
    url: 'https://api.github.com/repos/Aisen60/blog/issues/3',
    repository_url: 'https://api.github.com/repos/Aisen60/blog',
    labels_url:
      'https://api.github.com/repos/Aisen60/blog/issues/3/labels{/name}',
    comments_url: 'https://api.github.com/repos/Aisen60/blog/issues/3/comments',
    events_url: 'https://api.github.com/repos/Aisen60/blog/issues/3/events',
    html_url: 'https://github.com/Aisen60/blog/issues/3',
    id: 585728522,
    node_id: 'MDU6SXNzdWU1ODU3Mjg1MjI=',
    number: 3,
    title: '前端配置proxy代理',
    user: {
      login: 'Aisen60',
      id: 19791710,
      node_id: 'MDQ6VXNlcjE5NzkxNzEw',
      avatar_url: 'https://avatars1.githubusercontent.com/u/19791710?v=4',
      gravatar_id: '',
      url: 'https://api.github.com/users/Aisen60',
      html_url: 'https://github.com/Aisen60',
      followers_url: 'https://api.github.com/users/Aisen60/followers',
      following_url:
        'https://api.github.com/users/Aisen60/following{/other_user}',
      gists_url: 'https://api.github.com/users/Aisen60/gists{/gist_id}',
      starred_url:
        'https://api.github.com/users/Aisen60/starred{/owner}{/repo}',
      subscriptions_url: 'https://api.github.com/users/Aisen60/subscriptions',
      organizations_url: 'https://api.github.com/users/Aisen60/orgs',
      repos_url: 'https://api.github.com/users/Aisen60/repos',
      events_url: 'https://api.github.com/users/Aisen60/events{/privacy}',
      received_events_url:
        'https://api.github.com/users/Aisen60/received_events',
      type: 'User',
      site_admin: false,
    },
    labels: [
      {
        id: 1929150686,
        node_id: 'MDU6TGFiZWwxOTI5MTUwNjg2',
        url: 'https://api.github.com/repos/Aisen60/blog/labels/Webpack',
        name: 'Webpack',
        color: '5ba7e4',
        default: false,
        description: '',
      },
    ],
    state: 'open',
    locked: false,
    assignee: null,
    assignees: [],
    milestone: null,
    comments: 0,
    created_at: '2020-03-22T14:18:29Z',
    updated_at: '2020-03-23T15:33:05Z',
    closed_at: null,
    author_association: 'OWNER',
    active_lock_reason: null,
    body:
      "``` javaScript\r\nmodule.exports:{\r\n    proxy: {\r\n        \"/api\": {\r\n            //代理地址\r\n            target: \"http://127.0.0.1:3000\",\r\n            //路径重写\r\n            pathRewrite: {\r\n                \"^/api\": \"\"\r\n            }\r\n            // 如果是https接口，需要配置这个参数，并且为true。\r\n            secure: false, \r\n             //是否跨域\r\n            changeOrigin: true,\r\n        },\r\n    },\r\n}\r\n```\r\n\r\n### 参数说明:\r\n\r\n#### **'/api'** 和 **'target'** 是什么？\r\n\r\n这个是做匹配用的，匹配项目中所有接口都是以**'/api'**开头的，重定向到 **http://localhost**。\r\n\r\n比如说，有一个接口的格式为 **'/api/user/getUserInfo'**，它等价于 **http://localhost/user/getUserInfo**\r\n\r\n所以，我们写ajax请求的时候，就可以写成下面这样子\r\n\r\n```javaScript\r\n$.ajax({\r\n    // 不使用代理\r\n    // url: 'http://localhost/user/getUserInfo', \r\n    //使用代理\r\n    url: '/api/user/getUserInfo', \r\n});\r\n\r\n```\r\n**注意：这个/api 是自定义。**\r\n\r\n#### **'pathRewrite'** 是什么？\r\n\r\n这个是路径重写，可以修改最终的请求地址。\r\n\r\n比如说，后端有一个接口的路由名为 **/module/user/getSbZqt**,就可以设置为\r\n\r\n```javaScript\r\npathRewrite: {\r\n    \"^/api\": \"/module\"\r\n}\r\n```\r\n\r\n最终访问的地址就是：**http://localhost/module/user/getUserInfo**\r\n\r\n你可能会想到，那接写 **/module** 不就可以了吗？为什么还要写 **/api**?\r\n\r\n这个问题的话，看公司项目项目规范吧，有些项目会涉及会用到多个代理。又或者有些公司为了区分是接口。\r\n\r\n多个代理的场景最通常的情况就是，你和多个后端的同事在对接口。a同事和b同事的ip都不一样，这个时候就可以用的上啦。\r\n\r\n#### **'secure'** 是什么？\r\n可以这么来理解，如果是https接口，需要配置这个参数，并且为true。如果不是https，设置为false。\r\n\r\n#### **'changeOrigin'** 是什么？\r\n这个参数，一开始不知道什么意思？我去github上查阅了[官方文档](https://github.com/chimurai/http-proxy-middleware)，是英文的，翻译了一下\r\n\r\n原文：\r\n\r\nrue/false, Default: false - changes the origin of the host header to the target URL\r\n\r\n译文：\r\n\r\ntrue/false，默认值:false——将主机标头的来源更改为目标URL\r\n\r\n后来查了资料，在加上我的理解。可以这样理解：\r\n\r\n后端在接收到前端的请求的时候，是可以获取到host的，**host就是请求的ip来源**,这个默认值是**false**。\r\n\r\n如果 **changeOrigin为false** , 就是请求中的host就是你本地的host，比如localshost。\r\n\r\n如果 **changeOrigin为true** , 就是把host替换为代理的域名，比如xxx.com。\r\n\r\n<p style='color:red'>主要看后端的服务器有没有做host和referrer的判断,服务端可能判断如果host和referrer不对的话，就不提供服务。</p>\r\n\r\n\r\n#### 参考资料\r\nhttp-proxy-middleware：[ https://github.com/chimurai/http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware)\r\n\r\nvue cli 官网：[https://cli.vuejs.org/zh/config/#devserver-proxy](https://cli.vuejs.org/zh/config/#devserver-proxy)",
    performed_via_github_app: null,
  },
]

export default {
  bio,
  cardData,
}
